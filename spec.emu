<!doctype html>
<meta charset="utf8">
<link rel="stylesheet" href="./spec.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">
<script src="./spec.js"></script>
<pre class="metadata">
title: Deferred re-exports
stage: -1
contributors: Nicolò Ribaudo
</pre>

<emu-clause id="sec-ecmascript-language-scripts-and-modules" number="16">
  <h1>ECMAScript Language: Scripts and Modules</h1>

  <emu-clause id="sec-modules" number="2">
    <h1>Modules</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      Module :
        ModuleBody?

      ModuleBody :
        ModuleItemList

      ModuleItemList :
        ModuleItem
        ModuleItemList ModuleItem

      ModuleItem :
        ImportDeclaration
        ExportDeclaration
        StatementListItem[~Yield, +Await, ~Return]

      ModuleExportName :
        IdentifierName
        StringLiteral
    </emu-grammar>

    <emu-clause id="sec-module-semantics">
      <h1>Module Semantics</h1>

      <emu-clause id="sec-static-semantics-modulerequests" oldids="sec-module-semantics-static-semantics-modulerequests,sec-imports-static-semantics-modulerequests,sec-exports-static-semantics-modulerequests" type="sdo" number="4">
        <h1>Static Semantics: ModuleRequests ( ): a List of ModuleRequest Records</h1>
        <dl class="header">
        </dl>
        <emu-grammar>
          <ins>ExportDeclaration : `export` `defer` ExportFromClause FromClause WithClause? `;`</ins>
        </emu-grammar>
        <emu-alg>
          1. <ins>Return a new empty List.</ins>
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-cyclic-module-records" number="6">
        <h1>Cyclic Module Records</h1>
        <p>A <dfn id="cyclic-module-record" variants="Cyclic Module Records">Cyclic Module Record</dfn> is used to represent information about a module that can participate in dependency cycles with other modules that are subclasses of the Cyclic Module Record type. Module Records that are not subclasses of the Cyclic Module Record type must not participate in dependency cycles with Source Text Module Records.</p>
        <p>In addition to the fields defined in <emu-xref href="#table-module-record-fields"></emu-xref> Cyclic Module Records have the additional fields listed in <emu-xref href="#table-cyclic-module-fields"></emu-xref></p>
        <emu-table id="table-cyclic-module-fields" caption="Additional Fields of Cyclic Module Records">
          <table>
            <thead>
              <tr>
                <th>
                  Field Name
                </th>
                <th>
                  Value Type
                </th>
                <th>
                  Meaning
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[Status]]
              </td>
              <td>
                ~new~, ~unlinked~, ~linking~, ~linked~, ~evaluating~, ~evaluating-async~, or ~evaluated~
              </td>
              <td>
                Initially ~new~. Transitions to ~unlinked~, ~linking~, ~linked~, ~evaluating~, possibly ~evaluating-async~, ~evaluated~ (in that order) as the module progresses throughout its lifecycle. ~evaluating-async~ indicates this module is queued to execute on completion of its asynchronous dependencies or it is a module whose [[HasTLA]] field is *true* that has been executed and is pending top-level completion.
              </td>
            </tr>
            <tr>
              <td>
                [[EvaluationError]]
              </td>
              <td>
                a throw completion or ~empty~
              </td>
              <td>
                A throw completion representing the exception that occurred during evaluation. *undefined* if no exception occurred or if [[Status]] is not ~evaluated~.
              </td>
            </tr>
            <tr>
              <td>
                [[DFSIndex]]
              </td>
              <td>
                an integer or ~empty~
              </td>
              <td>
                Auxiliary field used during Link and Evaluate only. If [[Status]] is either ~linking~ or ~evaluating~, this non-negative number records the point at which the module was first visited during the depth-first traversal of the dependency graph.
              </td>
            </tr>
            <tr>
              <td>
                [[DFSAncestorIndex]]
              </td>
              <td>
                an integer or ~empty~
              </td>
              <td>
                Auxiliary field used during Link and Evaluate only. If [[Status]] is either ~linking~ or ~evaluating~, this is either the module's own [[DFSIndex]] or that of an "earlier" module in the same strongly connected component.
              </td>
            </tr>
            <tr>
              <td>
                [[RequestedModules]]
              </td>
              <td>
                a List of ModuleRequest Records
              </td>
              <td>
                A List of the ModuleRequest Records associated with the imports in this module. The List is in source text occurrence order of the imports.
              </td>
            </tr>
            <tr>
              <td>
                [[LoadedModules]]
              </td>
              <td>
                a List of LoadedModuleRequest Records
              </td>
              <td>
                A map from the specifier strings used by the module represented by this record to request the importation of a module with the relative import attributes to the resolved Module Record. The list does not contain two different Records _r1_ and _r2_ such that ModuleRequestsEqual(_r1_, _r2_) is *true*.
              </td>
            </tr>
            <tr>
              <td>
                <ins>[[OptionalIndirectExportEntries]]</ins>
              </td>
              <td>
                <ins>a List of ExportEntry Records whose [[LocalName]] is *null*.</ins>
              </td>
              <td>
                <ins>A list of all the bindings re-exported through `export defer { ... } from "..."`. The List is in source text occurrence order.</ins>
              </td>
            </tr>
            <tr>
              <td>
                [[CycleRoot]]
              </td>
              <td>
                a Cyclic Module Record or ~empty~
              </td>
              <td>
                The first visited module of the cycle, the root DFS ancestor of the strongly connected component. For a module not in a cycle, this would be the module itself. Once Evaluate has completed, a module's [[DFSAncestorIndex]] is the [[DFSIndex]] of its [[CycleRoot]].
              </td>
            </tr>
            <tr>
              <td>
                [[HasTLA]]
              </td>
              <td>
                a Boolean
              </td>
              <td>
                Whether this module is individually asynchronous (for example, if it's a Source Text Module Record containing a top-level await). Having an asynchronous dependency does not mean this field is *true*. This field must not change after the module is parsed.
              </td>
            </tr>
            <tr>
              <td>
                [[AsyncEvaluation]]
              </td>
              <td>
                a Boolean
              </td>
              <td>
                Whether this module is either itself asynchronous or has an asynchronous dependency. Note: The order in which this field is set is used to order queued executions, see <emu-xref href="#sec-async-module-execution-fulfilled"></emu-xref>.
              </td>
            </tr>
            <tr>
              <td>
                [[TopLevelCapability]]
              </td>
              <td>
                a PromiseCapability Record or ~empty~
              </td>
              <td>
                If this module is the [[CycleRoot]] of some cycle, and Evaluate() was called on some module in that cycle, this field contains the PromiseCapability Record for that entire evaluation. It is used to settle the Promise object that is returned from the Evaluate() abstract method. This field will be ~empty~ for any dependencies of that module, unless a top-level Evaluate() has been initiated for some of those dependencies.
              </td>
            </tr>
            <tr>
              <td>
                [[AsyncParentModules]]
              </td>
              <td>
                a List of Cyclic Module Records
              </td>
              <td>
                If this module or a dependency has [[HasTLA]] *true*, and execution is in progress, this tracks the parent importers of this module for the top-level execution job. These parent modules will not start executing before this module has successfully completed execution.
              </td>
            </tr>
            <tr>
              <td>
                [[PendingAsyncDependencies]]
              </td>
              <td>
                an integer or ~empty~
              </td>
              <td>
                If this module has any asynchronous dependencies, this tracks the number of asynchronous dependency modules remaining to execute for this module. A module with asynchronous dependencies will be executed when this field reaches 0 and there are no execution errors.
              </td>
            </tr>
          </table>
        </emu-table>
        <p>In addition to the methods defined in <emu-xref href="#table-abstract-methods-of-module-records"></emu-xref> Cyclic Module Records have the additional methods listed in <emu-xref href="#table-cyclic-module-methods"></emu-xref></p>
        <emu-table id="table-cyclic-module-methods" caption="Additional Abstract Methods of Cyclic Module Records">
          <table>
            <thead>
              <tr>
                <th>
                  Method
                </th>
                <th>
                  Purpose
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                InitializeEnvironment()
              </td>
              <td>
                Initialize the Environment Record of the module, including resolving all imported bindings, and create the module's execution context.
              </td>
            </tr>
            <tr>
              <td>
                ExecuteModule( [ _promiseCapability_ ] )
              </td>
              <td>
                Evaluate the module's code within its execution context. If this module has *true* in [[HasTLA]], then a PromiseCapability Record is passed as an argument, and the method is expected to resolve or reject the given capability. In this case, the method must not throw an exception, but instead reject the PromiseCapability Record if necessary.
              </td>
            </tr>
          </table>
        </emu-table>

        <p>A <dfn id="graphloadingstate-record" variants="GraphLoadingState Records">GraphLoadingState Record</dfn> is a Record that contains information about the loading process of a module graph. It's used to continue loading after a call to HostLoadImportedModule. Each GraphLoadingState Record has the fields defined in <emu-xref href="#table-graphloadingstate-record-fields"></emu-xref>:</p>
        <emu-table id="table-graphloadingstate-record-fields" caption="GraphLoadingState Record Fields">
          <table>
            <thead>
              <tr>
                <th>
                  Field Name
                </th>
                <th>
                  Value Type
                </th>
                <th>
                  Meaning
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[PromiseCapability]]
              </td>
              <td>
                a PromiseCapability Record
              </td>
              <td>
                The promise to resolve when the loading process finishes.
              </td>
            </tr>
            <tr>
              <td>
                [[IsLoading]]
              </td>
              <td>
                a Boolean
              </td>
              <td>
                It is true if the loading process has not finished yet, neither successfully nor with an error.
              </td>
            </tr>
            <tr>
              <td>
                [[PendingModulesCount]]
              </td>
              <td>
                a non-negative integer
              </td>
              <td>
                It tracks the number of pending HostLoadImportedModule calls.
              </td>
            </tr>
            <tr>
              <td>
                <ins>[[ContinuationData]]</ins>
              </td>
              <td>
                <ins>a List of Records with fields [[Referrer]] (a Cyclic Module Record), [[Specifier]] (a String), and [[ImportedNames]] (~all~ or a List of Strings)</ins>
              </td>
              <td>
                <ins>It stores data to be used for ContinueModuleLoading calls by FinishLoadingImportedModule.</ins>
              </td>
            </tr>
            <tr>
              <td>
                [[Visited]]
              </td>
              <td>
                a List of Cyclic Module Records
              </td>
              <td>
                It is a list of the Cyclic Module Records that have been already loaded by the current loading process, to avoid infinite loops with circular dependencies.
              </td>
            </tr>
            <tr>
              <td>
                [[HostDefined]]
              </td>
              <td>
                anything (default value is ~empty~)
              </td>
              <td>
                It contains host-defined data to pass from the LoadRequestedModules caller to HostLoadImportedModule.
              </td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-LoadRequestedModules" type="concrete method">
          <h1>
            LoadRequestedModules (
              <ins>_importedNames_: ~all~ or a List of Strings,</ins>
              optional _hostDefined_: anything,
            ): a Promise
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>a Cyclic Module Record _module_</dd>

            <dt>description</dt>
            <dd>It populates the [[LoadedModules]] of all the Module Records in the dependency graph of _module_ (most of the work is done by the auxiliary function InnerModuleLoading). It takes an optional _hostDefined_ parameter that is passed to the HostLoadImportedModule hook.</dd>
          </dl>

          <emu-alg>
            1. If _hostDefined_ is not present, let _hostDefined_ be ~empty~.
            1. Let _pc_ be ! NewPromiseCapability(%Promise%).
            1. Let _state_ be the GraphLoadingState Record { [[IsLoading]]: *true*, [[PendingModulesCount]]: 1, [[Visited]]: « », [[PromiseCapability]]: _pc_, [[HostDefined]]: _hostDefined_ }.
            1. Perform InnerModuleLoading(_state_, _module_, <ins>_importedNames_</ins>).
            1. Return _pc_.[[Promise]].
          </emu-alg>

          <emu-note>
            <ins>When the exports of the module are not observed, such as in <code>&lt;script type="module" src="./file.js"&gt;</code> tags, the host should set the _importedNames_ parameter to « ».</ins>
          </emu-note>

          <emu-note>
            The _hostDefined_ parameter can be used to pass additional information necessary to fetch the imported modules. It is used, for example, by HTML to set the correct fetch destination for <code>&lt;link rel="preload" as="..."&gt;</code> tags.
            <code>import()</code> expressions never set the _hostDefined_ parameter.
          </emu-note>

          <emu-clause id="sec-InnerModuleLoading" type="abstract operation">
            <h1>
              InnerModuleLoading (
                _state_: a GraphLoadingState Record,
                _module_: a Module Record,
                <ins>_importedNames_: ~all~ or a List of Strings,</ins>
              ): ~unused~
            </h1>
            <dl class="header">
              <dt>description</dt>
              <dd>It is used by LoadRequestedModules to recursively perform the actual loading process for _module_'s dependency graph.</dd>
            </dl>

            <emu-alg>
              1. Assert: _state_.[[IsLoading]] is *true*.
              1. <del>If _module_ is a Cyclic Module Record, _module_.[[Status]] is ~new~, and _state_.[[Visited]] does not contain _module_, then</del>
              1. <ins>If _module_ is a Cyclic Module Record, then</ins>
                1. <ins>Let _requestsToLoad_ be a new empty List.</ins>
                1. <ins>If _module_.[[Status]] is ~new~, and _state_.[[Visited]] does not contain _module_, then</ins>
                  1. Append _module_ to _state_.[[Visited]].
                  1. <ins>Set _requestsToLoad_ to _module_.[[RequestedModules]].</ins>
                1. <ins>Let _indirectRequests_ be GetOptionalIndirectExportsModuleRequests(_module_, _importedNames_).</ins>
                1. <ins>Set _requestsToLoad_ to the list-concatenation of _requestsToLoad_ and _indirectRequests_.</ins>
                1. Let _requestedModulesCount_ be the number of elements in <del>_module_.[[RequestedModules]]</del><ins>_requestsToLoad_</ins>.
                1. Set _state_.[[PendingModulesCount]] to _state_.[[PendingModulesCount]] + _requestedModulesCount_.
                1. For each ModuleRequest Record _request_ of <del>_module_.[[RequestedModules]]</del><ins>_requestsToLoad_</ins>, do
                  1. If AllImportAttributesSupported(_request_.[[Attributes]]) is *false*, then
                    1. Let _error_ be ThrowCompletion(a newly created *SyntaxError* object).
                    1. Perform ContinueModuleLoading(_state_, _error_, _request_.[[ImportedNames]]).
                  1. Else if _module_.[[LoadedModules]] contains a LoadedModuleRequest Record _record_ such that ModuleRequestsEqual(_record_, _request_) is *true*, then
                    1. Perform InnerModuleLoading(_state_, _record_.[[Module]], _request_.[[ImportedNames]]).
                  1. Else,
                    1. Perform HostLoadImportedModule(_module_, _request_, _state_.[[HostDefined]], _state_).
                    1. NOTE: HostLoadImportedModule will call FinishLoadingImportedModule, which re-enters the graph loading process through ContinueModuleLoading.
                  1. If _state_.[[IsLoading]] is *false*, return ~unused~.
              1. Assert: _state_.[[PendingModulesCount]] ≥ 1.
              1. Set _state_.[[PendingModulesCount]] to _state_.[[PendingModulesCount]] - 1.
              1. If _state_.[[PendingModulesCount]] = 0, then
                1. Set _state_.[[IsLoading]] to *false*.
                1. For each Cyclic Module Record _loaded_ of _state_.[[Visited]], do
                  1. If _loaded_.[[Status]] is ~new~, set _loaded_.[[Status]] to ~unlinked~.
                1. Perform ! Call(_state_.[[PromiseCapability]].[[Resolve]], *undefined*, « *undefined* »).
              1. Return ~unused~.
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-ContinueModuleLoading" type="abstract operation">
            <h1>
              ContinueModuleLoading (
                _state_: a GraphLoadingState Record,
                _moduleCompletion_: either a normal completion containing a Module Record or a throw completion,
                <ins>_importedNames_: ~all~ or a List of Strings,</ins>
              ): ~unused~
            </h1>
            <dl class="header">
              <dt>description</dt>
              <dd>It is used to re-enter the loading process after a call to HostLoadImportedModule.</dd>
            </dl>

            <emu-alg>
              1. If _state_.[[IsLoading]] is *false*, return ~unused~.
              1. If _moduleCompletion_ is a normal completion, then
                1. Perform InnerModuleLoading(_state_, _moduleCompletion_.[[Value]], <ins>_importedNames_</ins>).
              1. Else,
                1. Set _state_.[[IsLoading]] to *false*.
                1. Perform ! Call(_state_.[[PromiseCapability]].[[Reject]], *undefined*, « _moduleCompletion_.[[Value]] »).
              1. Return ~unused~.
            </emu-alg>
          </emu-clause>
        </emu-clause>

        <emu-clause id="sec-moduledeclarationlinking" type="concrete method" oldids="sec-moduledeclarationinstantiation">
          <h1>Link ( ): either a normal completion containing ~unused~ or a throw completion</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>a Cyclic Module Record _module_</dd>

            <dt>description</dt>
            <dd>On success, Link transitions this module's [[Status]] from ~unlinked~ to ~linked~. On failure, an exception is thrown and this module's [[Status]] remains ~unlinked~. (Most of the work is done by the auxiliary function InnerModuleLinking.)</dd>
          </dl>

          <emu-note type="editor">
            <p>TODO: Either we add an _importedNames_ parameter, or dynamic import will have to be responsible for linking all the defrred reexports.</p>
            <p>If we add that parameter, we must be careful because the used deferred re-exports of a module should be linked _after_ calling InitializeEnvironment on the module itself.</p>
          </emu-note>

          <emu-alg>
            1. Assert: _module_.[[Status]] is one of ~unlinked~, ~linked~, ~evaluating-async~, or ~evaluated~.
            1. Let _stack_ be a new empty List.
            1. Let _result_ be Completion(InnerModuleLinking(_module_, _stack_, 0)).
            1. If _result_ is an abrupt completion, then
              1. For each Cyclic Module Record _m_ of _stack_, do
                1. Assert: _m_.[[Status]] is ~linking~.
                1. Set _m_.[[Status]] to ~unlinked~.
              1. Assert: _module_.[[Status]] is ~unlinked~.
              1. Return ? _result_.
            1. Assert: _module_.[[Status]] is one of ~linked~, ~evaluating-async~, or ~evaluated~.
            1. Assert: _stack_ is empty.
            1. Return ~unused~.
          </emu-alg>

          <emu-clause id="sec-InnerModuleLinking" type="abstract operation" oldids="sec-innermoduleinstantiation">
            <h1>
              InnerModuleLinking (
                _module_: a Module Record,
                _stack_: a List of Cyclic Module Records,
                _index_: a non-negative integer,
              ): either a normal completion containing a non-negative integer or a throw completion
            </h1>
            <dl class="header">
              <dt>description</dt>
              <dd>It is used by Link to perform the actual linking process for _module_, as well as recursively on all other modules in the dependency graph. The _stack_ and _index_ parameters, as well as a module's [[DFSIndex]] and [[DFSAncestorIndex]] fields, keep track of the depth-first search (DFS) traversal. In particular, [[DFSAncestorIndex]] is used to discover strongly connected components (SCCs), such that all modules in an SCC transition to ~linked~ together.</dd>
            </dl>

            <emu-alg>
              1. If _module_ is not a Cyclic Module Record, then
                1. Perform ? _module_.Link().
                1. Return _index_.
              1. If _module_.[[Status]] is one of ~linking~, ~linked~, ~evaluating-async~, or ~evaluated~, then
                1. Return _index_.
              1. Assert: _module_.[[Status]] is ~unlinked~.
              1. Set _module_.[[Status]] to ~linking~.
              1. Set _module_.[[DFSIndex]] to _index_.
              1. Set _module_.[[DFSAncestorIndex]] to _index_.
              1. Set _index_ to _index_ + 1.
              1. Append _module_ to _stack_.
              1. <ins>Set _index_ to ? LinkRequestedModules(_module_, _module_, _module_.[[RequestedModules]], _stack_, _index_).</ins>
              1. <del>For each ModuleRequest Record _request_ of _module_.[[RequestedModules]], do</del>
                1. <del>Let _requiredModule_ be GetImportedModule(_module_, _request_).</del>
                1. <del>Set _index_ to ? InnerModuleLinking(_requiredModule_, _stack_, _index_).</del>
                1. <del>If _requiredModule_ is a Cyclic Module Record, then</del>
                  1. <del>Assert: _requiredModule_.[[Status]] is one of ~linking~, ~linked~, ~evaluating-async~, or ~evaluated~.</del>
                  1. <del>Assert: _requiredModule_.[[Status]] is ~linking~ if and only if _stack_ contains _requiredModule_.</del>
                  1. <del>If _requiredModule_.[[Status]] is ~linking~, then</del>
                    1. <del>Set _module_.[[DFSAncestorIndex]] to min(_module_.[[DFSAncestorIndex]], _requiredModule_.[[DFSAncestorIndex]]).</del>
              1. Perform ? _module_.InitializeEnvironment().
              1. Assert: _module_ occurs exactly once in _stack_.
              1. Assert: _module_.[[DFSAncestorIndex]] ≤ _module_.[[DFSIndex]].
              1. If _module_.[[DFSAncestorIndex]] = _module_.[[DFSIndex]], then
                1. Let _done_ be *false*.
                1. Repeat, while _done_ is *false*,
                  1. Let _requiredModule_ be the last element of _stack_.
                  1. Remove the last element of _stack_.
                  1. Assert: _requiredModule_ is a Cyclic Module Record.
                  1. Set _requiredModule_.[[Status]] to ~linked~.
                  1. If _requiredModule_ and _module_ are the same Module Record, set _done_ to *true*.
              1. Return _index_.
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-LinkRequestedModules" type="abstract operation">
            <h1>
              <ins>
                LinkRequestedModules (
                  _referrer_: a Cyclic Module Record,
                  _dfsAncestor_: a Cyclic Module Record,
                  _moduleRequests_: a List of ModuleRequest Records,
                  _stack_: a List of Cyclic Module Records,
                  _index_: a non-negative integer,
                ): either a normal completion containing a non-negative integer or a throw completion
              </ins>
            </h1>
            <dl class="header"></dl>
            <emu-alg>
              1. For each ModuleRequest Record _request_ of _moduleRequests_, do
                1. Let _requiredModule_ be GetImportedModule(_referrer_, _request_).
                1. Set _index_ to ? InnerModuleLinking(_requiredModule_, _stack_, _index_).
                1. If _requiredModule_ is a Cyclic Module Record, then
                  1. Assert: _requiredModule_.[[Status]] is one of ~linking~, ~linked~, ~evaluating-async~, or ~evaluated~.
                  1. Assert: _requiredModule_.[[Status]] is ~linking~ if and only if _stack_ contains _requiredModule_.
                  1. If _requiredModule_.[[Status]] is ~linking~, then
                    1. Set _dfsAncestor_.[[DFSAncestorIndex]] to min(_dfsAncestor_.[[DFSAncestorIndex]], _requiredModule_.[[DFSAncestorIndex]]).
                  1. Let _indirectRequests_ be GetOptionalIndirectExportsModuleRequests(_requiredModule_, _request_.[[ImportedNames]]).
                  1. Set _index_ to ? LinkRequestedModules(_requiredModule_, _dfsAncestor_, _indirectRequests_, _stack_, _index_).
              1. Return _index_.
            </emu-alg>

            <emu-note type="editor">
              TODO: There is an infinite loop if two modules `export defer` from each other.
            </emu-note>
          </emu-clause>
        </emu-clause>

        <emu-clause id="sec-moduleevaluation" type="concrete method">
          <h1>Evaluate ( ): a Promise</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>a Cyclic Module Record _module_</dd>

            <dt>description</dt>
            <dd>Evaluate transitions this module's [[Status]] from ~linked~ to either ~evaluating-async~ or ~evaluated~. The first time it is called on a module in a given strongly connected component, Evaluate creates and returns a Promise which resolves when the module has finished evaluating. This Promise is stored in the [[TopLevelCapability]] field of the [[CycleRoot]] for the component. Future invocations of Evaluate on any module in the component return the same Promise. (Most of the work is done by the auxiliary function InnerModuleEvaluation.)</dd>
          </dl>

          <emu-note type="editor">TODO: This needs to be updated</emu-note>

          <emu-alg>
            1. Assert: None of _module_ or any of its recursive dependencies have [[Status]] set to ~evaluating~, ~linking~, ~unlinked~, or ~new~.
            1. Assert: _module_.[[Status]] is one of ~linked~, ~evaluating-async~, or ~evaluated~.
            1. If _module_.[[Status]] is either ~evaluating-async~ or ~evaluated~, set _module_ to _module_.[[CycleRoot]].
            1. If _module_.[[TopLevelCapability]] is not ~empty~, then
              1. Return _module_.[[TopLevelCapability]].[[Promise]].
            1. Let _stack_ be a new empty List.
            1. Let _capability_ be ! NewPromiseCapability(%Promise%).
            1. Set _module_.[[TopLevelCapability]] to _capability_.
            1. Let _result_ be Completion(InnerModuleEvaluation(_module_, _stack_, 0)).
            1. If _result_ is an abrupt completion, then
              1. For each Cyclic Module Record _m_ of _stack_, do
                1. Assert: _m_.[[Status]] is ~evaluating~.
                1. Set _m_.[[Status]] to ~evaluated~.
                1. Set _m_.[[EvaluationError]] to _result_.
              1. Assert: _module_.[[Status]] is ~evaluated~.
              1. Assert: _module_.[[EvaluationError]] is _result_.
              1. Perform ! Call(_capability_.[[Reject]], *undefined*, « _result_.[[Value]] »).
            1. Else,
              1. Assert: _module_.[[Status]] is either ~evaluating-async~ or ~evaluated~.
              1. Assert: _module_.[[EvaluationError]] is ~empty~.
              1. If _module_.[[AsyncEvaluation]] is *false*, then
                1. Assert: _module_.[[Status]] is ~evaluated~.
                1. Perform ! Call(_capability_.[[Resolve]], *undefined*, « *undefined* »).
              1. Assert: _stack_ is empty.
            1. Return _capability_.[[Promise]].
          </emu-alg>

          <emu-clause id="sec-innermoduleevaluation" type="abstract operation">
            <h1>
              InnerModuleEvaluation (
                _module_: a Module Record,
                _stack_: a List of Cyclic Module Records,
                _index_: a non-negative integer,
              ): either a normal completion containing a non-negative integer or a throw completion
            </h1>
            <dl class="header">
              <dt>description</dt>
              <dd>It is used by Evaluate to perform the actual evaluation process for _module_, as well as recursively on all other modules in the dependency graph. The _stack_ and _index_ parameters, as well as _module_'s [[DFSIndex]] and [[DFSAncestorIndex]] fields, are used the same way as in InnerModuleLinking.</dd>
            </dl>

            <emu-alg>
              1. If _module_ is not a Cyclic Module Record, then
                1. Perform ? EvaluateSync(_module_).
                1. Return _index_.
              1. If _module_.[[Status]] is either ~evaluating-async~ or ~evaluated~, then
                1. If _module_.[[EvaluationError]] is ~empty~, return _index_.
                1. Otherwise, return ? _module_.[[EvaluationError]].
              1. If _module_.[[Status]] is ~evaluating~, return _index_.
              1. Assert: _module_.[[Status]] is ~linked~.
              1. Set _module_.[[Status]] to ~evaluating~.
              1. Set _module_.[[DFSIndex]] to _index_.
              1. Set _module_.[[DFSAncestorIndex]] to _index_.
              1. Set _module_.[[PendingAsyncDependencies]] to 0.
              1. Set _index_ to _index_ + 1.
              1. Let _evaluationList_ be a new empty List.
              1. For each ModuleRequest Record _required_ of _module_.[[RequestedModules]], do
                1. Let _requiredModule_ be GetImportedModule(_module_, _required_.[[Specifier]]).
                1. If _required_.[[Phase]] is ~defer~, then
                  1. Let _additionalModules_ be GatherAsynchronousTransitiveDependencies(_requiredModule_).
                  1. For each Module Record _additionalModule_ of _additionalModules_, do
                    1. If _evaluationList_ does not contain _additionalModule_, then
                      1. Append _additionalModule_ to _evaluationList_.
                1. Else if _evaluationList_ does not contain _requiredModule_, then
                  1. Append _requiredModule_ to _evaluationList_.
              1. Append _module_ to _stack_.
              1. For each Module Record _requiredModule_ of _evaluationList_, do
                1. Set _index_ to ? InnerModuleEvaluation(_requiredModule_, _stack_, _index_).
                1. If _requiredModule_ is a Cyclic Module Record, then
                  1. Assert: _requiredModule_.[[Status]] is one of ~evaluating~, ~evaluating-async~, or ~evaluated~.
                  1. Assert: _requiredModule_.[[Status]] is ~evaluating~ if and only if _stack_ contains _requiredModule_.
                  1. If _requiredModule_.[[Status]] is ~evaluating~, then
                    1. Set _module_.[[DFSAncestorIndex]] to min(_module_.[[DFSAncestorIndex]], _requiredModule_.[[DFSAncestorIndex]]).
                  1. Else,
                    1. Set _requiredModule_ to _requiredModule_.[[CycleRoot]].
                    1. Assert: _requiredModule_.[[Status]] is either ~evaluating-async~ or ~evaluated~.
                    1. If _requiredModule_.[[EvaluationError]] is not ~empty~, return ? _requiredModule_.[[EvaluationError]].
                  1. If _requiredModule_.[[AsyncEvaluation]] is *true*, then
                    1. Set _module_.[[PendingAsyncDependencies]] to _module_.[[PendingAsyncDependencies]] + 1.
                    1. Append _module_ to _requiredModule_.[[AsyncParentModules]].
              1. If _module_.[[PendingAsyncDependencies]] > 0 or _module_.[[HasTLA]] is *true*, then
                1. Assert: _module_.[[AsyncEvaluation]] is *false*.
                1. Set _module_.[[AsyncEvaluation]] to *true*.
                1. NOTE: The order in which module records have their [[AsyncEvaluation]] fields transition to *true* is significant. (See <emu-xref href="#sec-async-module-execution-fulfilled"></emu-xref>.)
                1. If _module_.[[PendingAsyncDependencies]] = 0, perform ExecuteAsyncModule(_module_).
              1. Else,
                1. Perform ? <emu-meta effects="user-code">_module_.ExecuteModule()</emu-meta>.
              1. Assert: _module_ occurs exactly once in _stack_.
              1. Assert: _module_.[[DFSAncestorIndex]] ≤ _module_.[[DFSIndex]].
              1. If _module_.[[DFSAncestorIndex]] = _module_.[[DFSIndex]], then
                1. Let _done_ be *false*.
                1. Repeat, while _done_ is *false*,
                  1. Let _requiredModule_ be the last element of _stack_.
                  1. Remove the last element of _stack_.
                  1. Assert: _requiredModule_ is a Cyclic Module Record.
                  1. If _requiredModule_.[[AsyncEvaluation]] is *false*, then
                    1. Set _requiredModule_.[[Status]] to ~evaluated~.
                  1. Else,
                    1. Set _requiredModule_.[[Status]] to ~evaluating-async~.
                  1. If _requiredModule_ and _module_ are the same Module Record, set _done_ to *true*.
                  1. Set _requiredModule_.[[CycleRoot]] to _module_.
              1. Return _index_.
            </emu-alg>
            <emu-note>
              <p>A module is ~evaluating~ while it is being traversed by InnerModuleEvaluation. A module is ~evaluated~ on execution completion or ~evaluating-async~ during execution if its [[HasTLA]] field is *true* or if it has asynchronous dependencies.</p>
            </emu-note>
            <emu-note>
              <p>Any modules depending on a module of an asynchronous cycle when that cycle is not ~evaluating~ will instead depend on the execution of the root of the cycle via [[CycleRoot]]. This ensures that the cycle state can be treated as a single strongly connected component through its root module state.</p>
            </emu-note>
          </emu-clause>

          <emu-clause id="sec-EvaluateRequestedModules" type="abstract operation">
            <h1>
              <ins>
                EvaluateRequestedModules (
                  _referrer_: a Cyclic Module Record,
                  _dfsAncestor_: a Cyclic Module Record,
                  _moduleRequests_: a List of ModuleRequest Records,
                  _stack_: a List of Cyclic Module Records,
                  _index_: a non-negative integer,
                ): either a normal completion containing a non-negative integer or a throw completion
              </ins>
            </h1>
            <dl class="header"></dl>

            <emu-note type="editor"></emu-note>

            <emu-alg>
              1. For each ModuleRequest Record _request_ of _moduleRequests_, do
                1. Let _requiredModule_ be GetImportedModule(_referrer_, _request_).
                1. Set _index_ to ? InnerModuleEvaluation(_requiredModule_, _stack_, _index_).
                1. If _requiredModule_ is a Cyclic Module Record, then
                  1. Assert: _requiredModule_.[[Status]] is one of ~evaluating~, ~evaluating-async~, or ~evaluated~.
                  1. Assert: _requiredModule_.[[Status]] is ~evaluating~ if and only if _stack_ contains _requiredModule_.
                  1. If _requiredModule_.[[Status]] is ~evaluating~, then
                    1. Set _dfsAncestor_.[[DFSAncestorIndex]] to min(_dfsAncestor_.[[DFSAncestorIndex]], _requiredModule_.[[DFSAncestorIndex]]).
                  1. Else,
                    1. Set _requiredModule_ to _requiredModule_.[[CycleRoot]].
                    1. Assert: _requiredModule_.[[Status]] is either ~evaluating-async~ or ~evaluated~.
                    1. If _requiredModule_.[[EvaluationError]] is not ~empty~, return ? _requiredModule_.[[EvaluationError]].
                  1. If _requiredModule_.[[AsyncEvaluation]] is *true*, then
                    1. Set _dfsAncestor_.[[PendingAsyncDependencies]] to _dfsAncestor_.[[PendingAsyncDependencies]] + 1.
                    1. Append _dfsAncestor_ to _requiredModule_.[[AsyncParentModules]].
              1. Return _index_.
            </emu-alg>

            <emu-note type="editor">
              TODO: There is an infinite loop if two modules `export defer` from each other.
            </emu-note>
          </emu-clause>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-source-text-module-records" number="7">
        <h1>Source Text Module Records</h1>

        <emu-clause id="sec-parsemodule" type="abstract operation">
          <h1>
            ParseModule (
              _sourceText_: ECMAScript source text,
              _realm_: a Realm Record,
              _hostDefined_: anything,
            ): a Source Text Module Record or a non-empty List of *SyntaxError* objects
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It creates a Source Text Module Record based upon the result of parsing _sourceText_ as a |Module|.</dd>
          </dl>
          <emu-alg>
            1. Let _body_ be ParseText(_sourceText_, |Module|).
            1. If _body_ is a List of errors, return _body_.
            1. Let _requestedModules_ be the ModuleRequests of _body_.
            1. Let _importEntries_ be the ImportEntries of _body_.
            1. Let _importedBoundNames_ be ImportedLocalNames(_importEntries_).
            1. Let _indirectExportEntries_ be a new empty List.
            1. Let _localExportEntries_ be a new empty List.
            1. Let _starExportEntries_ be a new empty List.
            1. Let _exportEntries_ be the ExportEntries of _body_.
            1. For each ExportEntry Record _ee_ of _exportEntries_, do
              1. If _ee_.[[ModuleRequest]] is *null*, then
                1. If _importedBoundNames_ does not contain _ee_.[[LocalName]], then
                  1. Append _ee_ to _localExportEntries_.
                1. Else,
                  1. Let _ie_ be the element of _importEntries_ whose [[LocalName]] is _ee_.[[LocalName]].
                  1. If _ie_.[[ImportName]] is ~namespace-object~, then
                    1. NOTE: This is a re-export of an imported module namespace object.
                    1. Append _ee_ to _localExportEntries_.
                  1. Else,
                    1. NOTE: This is a re-export of a single name.
                    1. Append the ExportEntry Record { [[ModuleRequest]]: _ie_.[[ModuleRequest]], [[ImportName]]: _ie_.[[ImportName]], [[LocalName]]: *null*, [[ExportName]]: _ee_.[[ExportName]] } to _indirectExportEntries_.
              1. Else if _ee_.[[ImportName]] is ~all-but-default~, then
                1. Assert: _ee_.[[ExportName]] is *null*.
                1. Append _ee_ to _starExportEntries_.
              1. Else,
                1. Append _ee_ to _indirectExportEntries_.
            1. <ins>Let _optionalIndirectExportsEntries_ be OptionalIndirectExportEntries of _body_.</ins>
            1. Let _async_ be _body_ Contains `await`.
            1. Return Source Text Module Record { [[Realm]]: _realm_, [[Environment]]: ~empty~, [[Namespace]]: ~empty~, [[CycleRoot]]: ~empty~, [[HasTLA]]: _async_, [[AsyncEvaluationOrder]]: ~unset~, [[TopLevelCapability]]: ~empty~, [[AsyncParentModules]]: « », [[PendingAsyncDependencies]]: ~empty~, [[Status]]: ~new~, [[EvaluationError]]: ~empty~, [[HostDefined]]: _hostDefined_, [[ECMAScriptCode]]: _body_, [[Context]]: ~empty~, [[ImportMeta]]: ~empty~, [[RequestedModules]]: _requestedModules_, [[LoadedModules]]: « », [[ImportEntries]]: _importEntries_, [[LocalExportEntries]]: _localExportEntries_, [[IndirectExportEntries]]: _indirectExportEntries_, [[StarExportEntries]]: _starExportEntries_, <ins>[[OptionalIndirectExportEntries]]: _optionalIndirectExportsEntries_,</ins> [[DFSIndex]]: ~empty~, [[DFSAncestorIndex]]: ~empty~ }.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-GetOptionalIndirectExportsModuleRequests" type="abstract operation" number="100">
        <h1>
          <ins>
            GetOptionalIndirectExportsModuleRequests (
              _module_: a Cyclic Module Record,
              _importedNames_: ~all~ or a List of Strings,
            ): a List of ModuleRequest Records
          </ins>
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd></dd>
        </dl>

        <emu-alg>
          1. Let _requests_ be a new empty List.
          1. For each ExportEntry Record _oie_ of _module_.[[OptionalIndirectExportEntries]], do
            1. If _importedNames_ is ~all~ or _importedNames_ contains _oie_.[[ExportName]], then
              1. Let _nextRequest_ be _oie_.[[ModuleRequest]].
              1. Let _existingRequest_ be ~empty~.
              1. For each ModuleRequest Record _r_ in _requests_, do
                1. If _existingRequest_ is ~empty~ and ModuleRequestsEqual(_r_, _nextRequest_) is *true* and _r_.[[Phase]] is _nextRequest_.[[Phase]], then
                  1. Set _existingRequest_ to _r_.
              1. Let _newImportedNames_ be ~all~.
              1. Assert: _oie_.[[ImportName]] is a String or ~all~.
              1. If _oie_.[[ImportName]] is a String, set _newImportedNames_ to « _oie_.[[ImportName]] ».
              1. If _existingRequest_ is ~empty~, then
                1. Let _request_ be the ModuleRequest Record { [[Specifier]]: _nextRequest_.[[Specifier]], [[Attributes]]: _nextRequest_.[[Attributes]], [[Phase]]: _nextRequest_.[[Phase]], [[ImportedNames]]: _newImportedNames_ }.
                1. Append _request_ to _requests_.
              1. Else,
                1. Set _existingRequest_.[[ImportedNames]] to MergeImportedNames(_existingRequest_.[[ImportedNames]], _newImportedNames_).
          1. Return _requests_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-mergeimportednames" type="abstract operation">
        <h1>
          <ins>
            MergeImportedNames (
              _a_: ~all~ or a List of Strings,
              _b_: ~all~ or a List of Strings,
            ): ~all~ or a List of Strings
          </ins>
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd></dd>
        </dl>

        <emu-alg>
          1. If _a_ is ~all~ or _b_ is ~all~, return ~all~.
          1. Return the list-concatenation of _a_ and _b_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-exports" number="3">
      <h1>Exports</h1>

      <h2>Syntax</h2>
      <emu-grammar type="definition">
        ExportDeclaration :
          `export` <ins>`defer`?</ins> ExportFromClause FromClause WithClause? `;`
          `export` NamedExports `;`
          `export` VariableStatement[~Yield, +Await]
          `export` Declaration[~Yield, +Await]
          `export` `default` HoistableDeclaration[~Yield, +Await, +Default]
          `export` `default` ClassDeclaration[~Yield, +Await, +Default]
          `export` `default` [lookahead &notin; { `function`, `async` [no LineTerminator here] `function`, `class` }] AssignmentExpression[+In, ~Yield, +Await] `;`

        ExportFromClause :
          `*`
          <del>`*` `as` ModuleExportName</del>
          <ins>NamedNamespaceExport</ins>
          NamedExports

        <ins>
        NamedNamespaceExport :
          `*` `as` ModuleExportName
        </ins>

        NamedExports :
          `{` `}`
          `{` ExportsList `}`
          `{` ExportsList `,` `}`

        ExportsList :
          ExportSpecifier
          ExportsList `,` ExportSpecifier

        ExportSpecifier :
          ModuleExportName
          ModuleExportName `as` ModuleExportName
      </emu-grammar>

      <emu-clause id="sec-exports-static-semantics-early-errors">
        <h1>Static Semantics: Early Errors</h1>
        <emu-grammar>ExportDeclaration : `export` NamedExports `;`</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if ReferencedBindings of |NamedExports| contains any |StringLiteral|s.
          </li>
          <li>
            For each |IdentifierName| _n_ in ReferencedBindings of |NamedExports|: It is a Syntax Error if StringValue of _n_ is a |ReservedWord| or the StringValue of _n_ is one of *"implements"*, *"interface"*, *"let"*, *"package"*, *"private"*, *"protected"*, *"public"*, or *"static"*.
          </li>
        </ul>
        <emu-note>
          <p>The above rule means that each ReferencedBindings of |NamedExports| is treated as an |IdentifierReference|.</p>
        </emu-note>
        <emu-grammar><ins>ExportDeclaration : `export` `defer` ExportFromClause FromClause WithClause? `;`</ins></emu-grammar>
        <ul>
          <li>
            <ins>It is a Syntax Error if |ExportFromClause| is `*`.</ins>
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-static-semantics-exportednames" type="sdo" number="3">
        <h1>Static Semantics: ExportedNames ( ): a List of Strings</h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>ExportedNames are the externally visible names that a |Module| explicitly maps to one of its local name bindings.</p>
        </emu-note>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. Let _names1_ be ExportedNames of |ModuleItemList|.
          1. Let _names2_ be ExportedNames of |ModuleItem|.
          1. Return the list-concatenation of _names1_ and _names2_.
        </emu-alg>
        <emu-grammar>ModuleItem : ExportDeclaration</emu-grammar>
        <emu-alg>
          1. Return the ExportedNames of |ExportDeclaration|.
        </emu-alg>
        <emu-grammar>
          ModuleItem :
            ImportDeclaration
            StatementListItem
        </emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` <ins>`defer`?</ins> ExportFromClause FromClause WithClause? `;`</emu-grammar>
        <emu-alg>
          1. Return the ExportedNames of |ExportFromClause|.
        </emu-alg>
        <emu-grammar>ExportFromClause : `*`</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ExportFromClause : `*` `as` ModuleExportName</emu-grammar>
        <emu-alg>
          1. Return a List whose sole element is the StringValue of |ModuleExportName|.
        </emu-alg>
        <emu-grammar>ExportFromClause : NamedExports</emu-grammar>
        <emu-alg>
          1. Return the ExportedNames of |NamedExports|.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` VariableStatement</emu-grammar>
        <emu-alg>
          1. Return the BoundNames of |VariableStatement|.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` Declaration</emu-grammar>
        <emu-alg>
          1. Return the BoundNames of |Declaration|.
        </emu-alg>
        <emu-grammar>
          ExportDeclaration :
            `export` `default` HoistableDeclaration
            `export` `default` ClassDeclaration
            `export` `default` AssignmentExpression `;`
        </emu-grammar>
        <emu-alg>
          1. Return « *"default"* ».
        </emu-alg>
        <emu-grammar>NamedExports : `{` `}`</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ExportsList : ExportsList `,` ExportSpecifier</emu-grammar>
        <emu-alg>
          1. Let _names1_ be the ExportedNames of |ExportsList|.
          1. Let _names2_ be the ExportedNames of |ExportSpecifier|.
          1. Return the list-concatenation of _names1_ and _names2_.
        </emu-alg>
        <emu-grammar>ExportSpecifier : ModuleExportName</emu-grammar>
        <emu-alg>
          1. Return a List whose sole element is the StringValue of |ModuleExportName|.
        </emu-alg>
        <emu-grammar>ExportSpecifier : ModuleExportName `as` ModuleExportName</emu-grammar>
        <emu-alg>
          1. Return a List whose sole element is the StringValue of the second |ModuleExportName|.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-exportentries" type="sdo" number="4">
        <h1>Static Semantics: ExportEntries ( ): a List of ExportEntry Records</h1>
        <dl class="header">
        </dl>
        <emu-grammar>Module : [empty]</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. Let _entries1_ be ExportEntries of |ModuleItemList|.
          1. Let _entries2_ be ExportEntries of |ModuleItem|.
          1. Return the list-concatenation of _entries1_ and _entries2_.
        </emu-alg>
        <emu-grammar>
          ModuleItem :
            ImportDeclaration
            StatementListItem
        </emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` <ins>`defer`?</ins> ExportFromClause FromClause WithClause? `;`</emu-grammar>
        <emu-alg>
          1. Let _module_ be the sole element of ModuleRequests of |FromClause|.
          1. Return ExportEntriesForModule of |ExportFromClause| with argument _module_.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` NamedExports `;`</emu-grammar>
        <emu-alg>
          1. Return ExportEntriesForModule of |NamedExports| with argument *null*.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` VariableStatement</emu-grammar>
        <emu-alg>
          1. Let _entries_ be a new empty List.
          1. Let _names_ be the BoundNames of |VariableStatement|.
          1. For each element _name_ of _names_, do
            1. Append the ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _name_, [[ExportName]]: _name_ } to _entries_.
          1. Return _entries_.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` Declaration</emu-grammar>
        <emu-alg>
          1. Let _entries_ be a new empty List.
          1. Let _names_ be the BoundNames of |Declaration|.
          1. For each element _name_ of _names_, do
            1. Append the ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _name_, [[ExportName]]: _name_ } to _entries_.
          1. Return _entries_.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` `default` HoistableDeclaration</emu-grammar>
        <emu-alg>
          1. Let _names_ be BoundNames of |HoistableDeclaration|.
          1. Let _localName_ be the sole element of _names_.
          1. Return a List whose sole element is a new ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _localName_, [[ExportName]]: *"default"* }.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` `default` ClassDeclaration</emu-grammar>
        <emu-alg>
          1. Let _names_ be BoundNames of |ClassDeclaration|.
          1. Let _localName_ be the sole element of _names_.
          1. Return a List whose sole element is a new ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _localName_, [[ExportName]]: *"default"* }.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` `default` AssignmentExpression `;`</emu-grammar>
        <emu-alg>
          1. Let _entry_ be the ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: *"\*default\*"*, [[ExportName]]: *"default"* }.
          1. Return « _entry_ ».
        </emu-alg>
        <emu-note>
          <p>*"\*default\*"* is used within this specification as a synthetic name for anonymous default export values. See <emu-xref href="#note-star-default-star">this note</emu-xref> for more details.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-static-semantics-optionalindirectexportentries" type="sdo">
        <h1>
          <ins>
            Static Semantics: OptionalIndirectExportEntries ( ): a List of ExportEntry Records
          </ins>
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>Module : [empty]</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. Let _entries1_ be OptionalIndirectExportEntries of |ModuleItemList|.
          1. Let _entries2_ be OptionalIndirectExportEntries of |ModuleItem|.
          1. Return the list-concatenation of _entries1_ and _entries2_.
        </emu-alg>
        <emu-grammar>
          ModuleItem :
            ImportDeclaration
            StatementListItem

          ExportDeclaration :
            `export` ExportFromClause FromClause WithClause? `;`
            `export` NamedExports `;`
            `export` VariableStatement
            `export` Declaration
            `export` `default` HoistableDeclaration
            `export` `default` ClassDeclaration
            `export` `default` AssignmentExpression `;`
        </emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` `defer` ExportFromClause FromClause WithClause? `;`</emu-grammar>
        <emu-alg>
          1. Return ExportEntries of |ExportDeclaration|.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>
