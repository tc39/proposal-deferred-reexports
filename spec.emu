<!doctype html>
<meta charset="utf8">
<link rel="stylesheet" href="./spec.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">
<script src="./spec.js"></script>
<pre class="metadata">
title: Deferred re-exports
stage: 2
contributors: Nicolò Ribaudo
</pre>

<emu-note type="editor">
  <p style="margin-left:1em">NOTE: The diff markers are on top of <a href="https://tc39.es/proposal-defer-import-eval/">https://tc39.es/proposal-defer-import-eval/</a>.</p>
</emu-note>

<emu-clause id="sec-ordinary-and-exotic-objects-behaviours" number="10">
  <h1>Ordinary and Exotic Objects Behaviours</h1>

  <emu-clause id="sec-built-in-exotic-object-internal-methods-and-slots" number="4">
    <h1>Built-in Exotic Object Internal Methods and Slots</h1>
    <p>This specification defines several kinds of built-in exotic objects. These objects generally behave similar to ordinary objects except for a few specific situations. The following exotic objects use the ordinary object internal methods except where it is explicitly specified otherwise below:</p>

    <emu-clause id="sec-module-namespace-exotic-objects" oldids="sec-module-namespace-objects" number="6">
      <h1>Module Namespace Exotic Objects</h1>
      <p>A module namespace exotic object is an exotic object that exposes the bindings exported from an ECMAScript |Module| (See <emu-xref href="#sec-exports"></emu-xref>). There is a one-to-one correspondence between the String-keyed own properties of a module namespace exotic object and the binding names exported by the |Module|. The exported bindings include any bindings that are indirectly exported using `export *` export items. Each String-valued own property key is the StringValue of the corresponding exported binding name. These are the only String-keyed properties of a module namespace exotic object. Each such property has the attributes { [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: *false* }. Module namespace exotic objects are not extensible.</p>
      <p>An object is a <dfn id="module-namespace-exotic-object" variants="module namespace exotic objects">module namespace exotic object</dfn> if its [[GetPrototypeOf]], [[SetPrototypeOf]], [[IsExtensible]], [[PreventExtensions]], [[GetOwnProperty]], [[DefineOwnProperty]], [[HasProperty]], [[Get]], [[Set]], [[Delete]], and [[OwnPropertyKeys]] internal methods use the definitions in this section, and its other essential internal methods use the definitions found in <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref>. These methods are installed by ModuleNamespaceCreate.</p>
      <p>Module namespace exotic objects have the internal slots defined in <emu-xref href="#table-internal-slots-of-module-namespace-exotic-objects"></emu-xref>.</p>

      <emu-clause id="sec-module-namespace-exotic-objects-get-p-receiver" type="internal method" number="8">
        <h1>
          [[Get]] (
            _P_: a property key,
            _Receiver_: an ECMAScript language value,
          ): either a normal completion containing an ECMAScript language value or a throw completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>a module namespace exotic object _O_</dd>
        </dl>
        <emu-alg>
          1. If IsSymbolLikeNamespaceKey(_P_, _O_), return ! OrdinaryGet(_O_, _P_, _Receiver_).
          1. Let _exports_ be ? GetModuleExportsList(_O_).
          1. If _exports_ does not contain _P_, return *undefined*.
          1. Let _m_ be _O_.[[Module]].
          1. Let _binding_ be _m_.ResolveExport(_P_).
          1. <span style="background:yellow">TODO: The line above should also get a list of intermediate modules to evaluate.</span>
          1. Assert: _binding_ is a ResolvedBinding Record.
          1. Let _targetModule_ be _binding_.[[Module]].
          1. Assert: _targetModule_ is not *undefined*.
          1. If _binding_.[[BindingName]] is ~namespace~, then
            1. Return GetModuleNamespace(_targetModule_, ~evaluation~).
            1. NOTE: The phase here is always ~evaluation~ because in `import defer * as x from "..."; export { x }`, _binding_.[[BindingName]] is *"x"* and not ~namespace~.
          1. Let _targetEnv_ be _targetModule_.[[Environment]].
          1. If _targetEnv_ is ~empty~, throw a *ReferenceError* exception.
          1. Return ? _targetEnv_.GetBindingValue(_binding_.[[BindingName]], *true*).
        </emu-alg>
        <emu-note>
          <p>ResolveExport is side-effect free. Each time this operation is called with a specific _exportName_, _resolveSet_ pair as arguments it must return the same result. An implementation might choose to pre-compute or cache the ResolveExport results for the [[Exports]] of each module namespace exotic object.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-expressions" number="13">
  <h1>ECMAScript Language: Expressions</h1>

  <emu-clause id="sec-left-hand-side-expressions" number="3">
    <h1>Left-Hand-Side Expressions</h1>

    <emu-clause id="sec-import-calls" number="10">
      <h1>Import Calls</h1>

      <emu-clause id="sec-evaluate-import-call" type="abstract operation">
        <h1>
          EvaluateImportCall (
            _arguments_: a Parse Node,
            _phase_: ~defer~ or ~evaluation~,
          ): either a normal completion containing a Promise or an abrupt completion
        </h1>
        <dl class="header"></dl>
        <emu-alg>
          1. Let _referrer_ be GetActiveScriptOrModule().
          1. If _referrer_ is *null*, set _referrer_ to the current Realm Record.
          1. Let _specifier_ be ? EvaluateImportCallSpecifier of _arguments_.
          1. Let _options_ be ? EvaluateImportCallOptions of _arguments_.
          1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).
          1. Let _specifierString_ be Completion(ToString(_specifier_)).
          1. IfAbruptRejectPromise(_specifierString_, _promiseCapability_).
          1. Let _attributes_ be a new empty List.
          1. If _options_ is not *undefined*, then
            1. If _options_ is not an Object, then
              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « a newly created *TypeError* object »).
              1. Return _promiseCapability_.[[Promise]].
            1. Let _attributesObj_ be Completion(Get(_options_, *"with"*)).
            1. IfAbruptRejectPromise(_attributesObj_, _promiseCapability_).
            1. If _attributesObj_ is not *undefined*, then
              1. If _attributesObj_ is not an Object, then
                1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « a newly created *TypeError* object »).
                1. Return _promiseCapability_.[[Promise]].
              1. Let _entries_ be Completion(EnumerableOwnProperties(_attributesObj_, ~key+value~)).
              1. IfAbruptRejectPromise(_entries_, _promiseCapability_).
              1. For each element _entry_ of _entries_, do
                1. Let _key_ be ! Get(_entry_, *"0"*).
                1. Let _value_ be ! Get(_entry_, *"1"*).
                1. If _key_ is a String, then
                  1. If _value_ is not a String, then
                    1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « a newly created *TypeError* object »).
                    1. Return _promiseCapability_.[[Promise]].
                  1. Append the ImportAttribute Record { [[Key]]: _key_, [[Value]]: _value_ } to _attributes_.
            1. If AllImportAttributesSupported(_attributes_) is *false*, then
              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « a newly created *TypeError* object »).
              1. Return _promiseCapability_.[[Promise]].
            1. Sort _attributes_ according to the lexicographic order of their [[Key]] field, treating the value of each such field as a sequence of UTF-16 code unit values. NOTE: This sorting is observable only in that hosts are prohibited from changing behaviour based on the order in which attributes are enumerated.
          1. Let _moduleRequest_ be a new ModuleRequest Record { [[Specifier]]: _specifierString_, [[Attributes]]: _attributes_, [[Phase]]: _phase_ }.
          1. Perform HostLoadImportedModule(_referrer_, _moduleRequest_, ~empty~, _promiseCapability_).
          1. Return _promiseCapability_.[[Promise]].
        </emu-alg>

        <emu-clause id="sec-ContinueDynamicImport" type="abstract operation">
          <h1>
            ContinueDynamicImport (
              _promiseCapability_: a PromiseCapability Record,
              _moduleCompletion_: either a normal completion containing a Module Record or a throw completion,
              _phase_: ~defer~ or ~evaluation~,
            ): ~unused~
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It completes the process of a dynamic import originally started by an <emu-xref href="#sec-import-calls">`import()`</emu-xref> call, resolving or rejecting the promise returned by that call as appropriate.</dd>
          </dl>
          <emu-alg>
            1. If _moduleCompletion_ is an abrupt completion, then
              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; _moduleCompletion_.[[Value]] &raquo;).
              1. Return ~unused~.
            1. Let _module_ be _moduleCompletion_.[[Value]].
            1. Let _loadPromise_ be _module_.LoadRequestedModules(<ins>~all~</ins>).
            1. Let _rejectedClosure_ be a new Abstract Closure with parameters (_reason_) that captures _promiseCapability_ and performs the following steps when called:
              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; _reason_ &raquo;).
              1. Return ~unused~.
            1. Let _onRejected_ be CreateBuiltinFunction(_rejectedClosure_, 1, *""*, &laquo; &raquo;).
            1. Let _linkAndEvaluateClosure_ be a new Abstract Closure with no parameters that captures _module_, _promiseCapability_, _phase_ and _onRejected_ and performs the following steps when called:
              1. Let _link_ be Completion(_module_.Link(<span style="background:yellow">TODO: ~all~?</span>)).
              1. If _link_ is an abrupt completion, then
                1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; _link_.[[Value]] &raquo;).
                1. Return ~unused~.
              1. Let _fulfilledClosure_ be a new Abstract Closure with no parameters that captures _module_, _phase_, and _promiseCapability_ and performs the following steps when called:
                1. Let _namespace_ be GetModuleNamespace(_module_, _phase_).
                1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, &laquo; _namespace_ &raquo;).
                1. Return ~unused~.
              1. If _phase_ is ~defer~, then
                1. Let _evaluationList_ be GatherAsynchronousTransitiveDependencies(_module_).
                1. If _evaluationList_ is empty, then
                  1. Perform _fulfilledClosure_().
                  1. Return ~unused~.
                1. Let _asyncDepsEvaluationPromises_ be a new empty List.
                1. For each Module Record _dep_ of _evaluationList_, append _dep_.Evaluate() to _asyncDepsEvaluationPromises_.
                1. Let _iterator_ be CreateListIteratorRecord(_asyncDepsEvaluationPromises_).
                1. Let _pc_ be ! NewPromiseCapability(%Promise%).
                1. Let _evaluatePromise_ be ! PerformPromiseAll(_iterator_, %Promise%, _pc_, %Promise.resolve%).
              1. Else,
                1. Assert: _phase_ is ~evaluation~.
                1. Let _evaluatePromise_ be _module_.Evaluate().
              1. Let _onFulfilled_ be CreateBuiltinFunction(_fulfilledClosure_, *""*, 0, &laquo; &raquo;).
              1. Perform PerformPromiseThen(_evaluatePromise_, _onFulfilled_, _onRejected_).
              1. Return ~unused~.
            1. Let _linkAndEvaluate_ be CreateBuiltinFunction(_linkAndEvaluateClosure_, *""*, 0, &laquo; &raquo;).
            1. Perform PerformPromiseThen(_loadPromise_, _linkAndEvaluate_, _onRejected_).
            1. Return ~unused~.
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-scripts-and-modules" number="16">
  <h1>ECMAScript Language: Scripts and Modules</h1>

  <emu-clause id="sec-modules" number="2">
    <h1>Modules</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      Module :
        ModuleBody?

      ModuleBody :
        ModuleItemList

      ModuleItemList :
        ModuleItem
        ModuleItemList ModuleItem

      ModuleItem :
        ImportDeclaration
        ExportDeclaration
        StatementListItem[~Yield, +Await, ~Return]

      ModuleExportName :
        IdentifierName
        StringLiteral
    </emu-grammar>

    <emu-clause id="sec-module-semantics">
      <h1>Module Semantics</h1>

      <emu-clause id="sec-static-semantics-modulerequests" oldids="sec-module-semantics-static-semantics-modulerequests,sec-imports-static-semantics-modulerequests,sec-exports-static-semantics-modulerequests" type="sdo" number="4">
        <h1>Static Semantics: ModuleRequests ( ): a List of ModuleRequest Records</h1>
        <dl class="header">
        </dl>
        <emu-grammar>
          <ins>ExportDeclaration : `export` `defer` ExportFromClause FromClause WithClause? `;`</ins>
        </emu-grammar>
        <emu-alg>
          1. <ins>Return a new empty List.</ins>
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-cyclic-module-records" number="6">
        <h1>Cyclic Module Records</h1>
        <p>A <dfn id="cyclic-module-record" variants="Cyclic Module Records">Cyclic Module Record</dfn> is used to represent information about a module that can participate in dependency cycles with other modules that are subclasses of the Cyclic Module Record type. Module Records that are not subclasses of the Cyclic Module Record type must not participate in dependency cycles with Source Text Module Records.</p>
        <p>In addition to the fields defined in <emu-xref href="#table-module-record-fields"></emu-xref> Cyclic Module Records have the additional fields listed in <emu-xref href="#table-cyclic-module-fields"></emu-xref></p>
        <emu-table id="table-cyclic-module-fields" caption="Additional Fields of Cyclic Module Records">
          <table>
            <thead>
              <tr>
                <th>
                  Field Name
                </th>
                <th>
                  Value Type
                </th>
                <th>
                  Meaning
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[Status]]
              </td>
              <td>
                ~new~, ~unlinked~, ~linking~, ~linked~, ~evaluating~, ~evaluating-async~, or ~evaluated~
              </td>
              <td>
                Initially ~new~. Transitions to ~unlinked~, ~linking~, ~linked~, ~evaluating~, possibly ~evaluating-async~, ~evaluated~ (in that order) as the module progresses throughout its lifecycle. ~evaluating-async~ indicates this module is queued to execute on completion of its asynchronous dependencies or it is a module whose [[HasTLA]] field is *true* that has been executed and is pending top-level completion.
              </td>
            </tr>
            <tr>
              <td>
                [[EvaluationError]]
              </td>
              <td>
                a throw completion or ~empty~
              </td>
              <td>
                A throw completion representing the exception that occurred during evaluation. *undefined* if no exception occurred or if [[Status]] is not ~evaluated~.
              </td>
            </tr>
            <tr>
              <td>
                [[DFSAncestorIndex]]
              </td>
              <td>
                an integer or ~empty~
              </td>
              <td>
                Auxiliary field used during Link and Evaluate only. If [[Status]] is either ~linking~ or ~evaluating~, this is either the module's depth-first traversal index or that of an "earlier" module in the same strongly connected component.
              </td>
            </tr>
            <tr>
              <td>
                [[RequestedModules]]
              </td>
              <td>
                a List of ModuleRequest Records
              </td>
              <td>
                A List of the ModuleRequest Records associated with the imports in this module. The List is in source text occurrence order of the imports.
              </td>
            </tr>
            <tr>
              <td>
                [[LoadedModules]]
              </td>
              <td>
                a List of LoadedModuleRequest Records
              </td>
              <td>
                A map from the specifier strings used by the module represented by this record to request the importation of a module with the relative import attributes to the resolved Module Record. The list does not contain two different Records _r1_ and _r2_ such that ModuleRequestsEqual(_r1_, _r2_) is *true*.
              </td>
            </tr>
            <tr>
              <td>
                <ins>[[OptionalIndirectExportEntries]]</ins>
              </td>
              <td>
                <ins>a List of ExportEntry Records whose [[LocalName]] is *null*.</ins>
              </td>
              <td>
                <ins>A list of all the bindings re-exported through `export defer { ... } from "..."`. The List is in source text occurrence order.</ins>
              </td>
            </tr>
            <tr>
              <td>
                [[CycleRoot]]
              </td>
              <td>
                a Cyclic Module Record or ~empty~
              </td>
              <td>
                The first visited module of the cycle, the root DFS ancestor of the strongly connected component. For a module not in a cycle, this would be the module itself. Once Evaluate has completed, a module's [[DFSAncestorIndex]] is the depth-first traversal index of its [[CycleRoot]].
              </td>
            </tr>
            <tr>
              <td>
                [[HasTLA]]
              </td>
              <td>
                a Boolean
              </td>
              <td>
                Whether this module is individually asynchronous (for example, if it's a Source Text Module Record containing a top-level await). Having an asynchronous dependency does not mean this field is *true*. This field must not change after the module is parsed.
              </td>
            </tr>
            <tr>
              <td>
                [[AsyncEvaluationOrder]]
              </td>
              <td>
                ~unset~, an integer, or ~done~
              </td>
              <td>
                This field is initially set to ~unset~, and remains ~unset~ for fully synchronous modules. For modules that are either themselves asynchronous or have an asynchronous dependency, it is set to an integer that determines the order in which execution of pending modules is queued by <emu-xref href="#sec-async-module-execution-fulfilled"></emu-xref>. Once the pending module is executed, the field is set to ~done~.
              </td>
            </tr>
            <tr>
              <td>
                [[TopLevelCapability]]
              </td>
              <td>
                a PromiseCapability Record or ~empty~
              </td>
              <td>
                If this module is the [[CycleRoot]] of some cycle, and Evaluate() was called on some module in that cycle, this field contains the PromiseCapability Record for that entire evaluation. It is used to settle the Promise object that is returned from the Evaluate() abstract method. This field will be ~empty~ for any dependencies of that module, unless a top-level Evaluate() has been initiated for some of those dependencies.
              </td>
            </tr>
            <tr>
              <td>
                [[AsyncParentModules]]
              </td>
              <td>
                a List of Cyclic Module Records
              </td>
              <td>
                If this module or a dependency has [[HasTLA]] *true*, and execution is in progress, this tracks the parent importers of this module for the top-level execution job. These parent modules will not start executing before this module has successfully completed execution.
              </td>
            </tr>
            <tr>
              <td>
                [[PendingAsyncDependencies]]
              </td>
              <td>
                an integer or ~empty~
              </td>
              <td>
                If this module has any asynchronous dependencies, this tracks the number of asynchronous dependency modules remaining to execute for this module. A module with asynchronous dependencies will be executed when this field reaches 0 and there are no execution errors.
              </td>
            </tr>
          </table>
        </emu-table>
        <p>In addition to the methods defined in <emu-xref href="#table-abstract-methods-of-module-records"></emu-xref> Cyclic Module Records have the additional methods listed in <emu-xref href="#table-cyclic-module-methods"></emu-xref></p>
        <emu-table id="table-cyclic-module-methods" caption="Additional Abstract Methods of Cyclic Module Records">
          <table>
            <thead>
              <tr>
                <th>
                  Method
                </th>
                <th>
                  Purpose
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                InitializeEnvironment()
              </td>
              <td>
                Initialize the Environment Record of the module, including resolving all imported bindings, and create the module's execution context.
              </td>
            </tr>
            <tr>
              <td>
                ExecuteModule( [ _promiseCapability_ ] )
              </td>
              <td>
                Evaluate the module's code within its execution context. If this module has *true* in [[HasTLA]], then a PromiseCapability Record is passed as an argument, and the method is expected to resolve or reject the given capability. In this case, the method must not throw an exception, but instead reject the PromiseCapability Record if necessary.
              </td>
            </tr>
          </table>
        </emu-table>

        <p>A <dfn id="graphloadingstate-record" variants="GraphLoadingState Records">GraphLoadingState Record</dfn> is a Record that contains information about the loading process of a module graph. It's used to continue loading after a call to HostLoadImportedModule. Each GraphLoadingState Record has the fields defined in <emu-xref href="#table-graphloadingstate-record-fields"></emu-xref>:</p>
        <emu-table id="table-graphloadingstate-record-fields" caption="GraphLoadingState Record Fields">
          <table>
            <thead>
              <tr>
                <th>
                  Field Name
                </th>
                <th>
                  Value Type
                </th>
                <th>
                  Meaning
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[PromiseCapability]]
              </td>
              <td>
                a PromiseCapability Record
              </td>
              <td>
                The promise to resolve when the loading process finishes.
              </td>
            </tr>
            <tr>
              <td>
                [[IsLoading]]
              </td>
              <td>
                a Boolean
              </td>
              <td>
                It is true if the loading process has not finished yet, neither successfully nor with an error.
              </td>
            </tr>
            <tr>
              <td>
                [[PendingModulesCount]]
              </td>
              <td>
                a non-negative integer
              </td>
              <td>
                It tracks the number of pending HostLoadImportedModule calls.
              </td>
            </tr>
            <tr>
              <td>
                <ins>[[ContinuationData]]</ins>
              </td>
              <td>
                <ins>a List of Records with fields [[Referrer]] (a Cyclic Module Record), [[Specifier]] (a String), and [[ImportedNames]] (~all~ or a List of Strings)</ins>
              </td>
              <td>
                <ins>It stores data to be used for ContinueModuleLoading calls by FinishLoadingImportedModule.</ins>
              </td>
            </tr>
            <tr>
              <td>
                [[Visited]]
              </td>
              <td>
                a List of Cyclic Module Records
              </td>
              <td>
                It is a list of the Cyclic Module Records that have been already loaded by the current loading process, to avoid infinite loops with circular dependencies.
              </td>
            </tr>
            <tr>
              <td>
                [[HostDefined]]
              </td>
              <td>
                anything (default value is ~empty~)
              </td>
              <td>
                It contains host-defined data to pass from the LoadRequestedModules caller to HostLoadImportedModule.
              </td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-LoadRequestedModules" type="concrete method">
          <h1>
            LoadRequestedModules (
              <ins>_importedNames_: ~all~ or a List of Strings,</ins>
              optional _hostDefined_: anything,
            ): a Promise
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>a Cyclic Module Record _module_</dd>

            <dt>description</dt>
            <dd>It populates the [[LoadedModules]] of all the Module Records in the dependency graph of _module_ (most of the work is done by the auxiliary function InnerModuleLoading). It takes an optional _hostDefined_ parameter that is passed to the HostLoadImportedModule hook.</dd>
          </dl>

          <emu-alg>
            1. If _hostDefined_ is not present, let _hostDefined_ be ~empty~.
            1. Let _pc_ be ! NewPromiseCapability(%Promise%).
            1. Let _state_ be the GraphLoadingState Record { [[IsLoading]]: *true*, [[PendingModulesCount]]: 1, [[Visited]]: « », [[PromiseCapability]]: _pc_, [[HostDefined]]: _hostDefined_ }.
            1. Perform InnerModuleLoading(_state_, _module_, <ins>_importedNames_</ins>).
            1. Return _pc_.[[Promise]].
          </emu-alg>

          <emu-note>
            <ins>When the exports of the module are not observed, such as in <code>&lt;script type="module" src="./file.js"&gt;</code> tags, the host should set the _importedNames_ parameter to « ».</ins>
          </emu-note>

          <emu-note>
            The _hostDefined_ parameter can be used to pass additional information necessary to fetch the imported modules. It is used, for example, by HTML to set the correct fetch destination for <code>&lt;link rel="preload" as="..."&gt;</code> tags.
            <code>import()</code> expressions never set the _hostDefined_ parameter.
          </emu-note>

          <emu-clause id="sec-InnerModuleLoading" type="abstract operation">
            <h1>
              InnerModuleLoading (
                _state_: a GraphLoadingState Record,
                _module_: a Module Record,
                <ins>_importedNames_: ~all~ or a List of Strings,</ins>
              ): ~unused~
            </h1>
            <dl class="header">
              <dt>description</dt>
              <dd>It is used by LoadRequestedModules to recursively perform the actual loading process for _module_'s dependency graph.</dd>
            </dl>

            <emu-alg>
              1. Assert: _state_.[[IsLoading]] is *true*.
              1. <del>If _module_ is a Cyclic Module Record, _module_.[[Status]] is ~new~, and _state_.[[Visited]] does not contain _module_, then</del>
              1. <ins>If _module_ is a Cyclic Module Record, then</ins>
                1. <ins>Let _requestsToLoad_ be a new empty List.</ins>
                1. <ins>If _module_.[[Status]] is ~new~, and _state_.[[Visited]] does not contain _module_, then</ins>
                  1. Append _module_ to _state_.[[Visited]].
                  1. <ins>Set _requestsToLoad_ to _module_.[[RequestedModules]].</ins>
                1. <ins>Let _indirectRequests_ be GetOptionalIndirectExportsModuleRequests(_module_, _importedNames_).</ins>
                1. <ins>Set _requestsToLoad_ to the list-concatenation of _requestsToLoad_ and _indirectRequests_.</ins>
                1. Let _requestedModulesCount_ be the number of elements in <del>_module_.[[RequestedModules]]</del><ins>_requestsToLoad_</ins>.
                1. Set _state_.[[PendingModulesCount]] to _state_.[[PendingModulesCount]] + _requestedModulesCount_.
                1. For each ModuleRequest Record _request_ of <del>_module_.[[RequestedModules]]</del><ins>_requestsToLoad_</ins>, do
                  1. If AllImportAttributesSupported(_request_.[[Attributes]]) is *false*, then
                    1. Let _error_ be ThrowCompletion(a newly created *SyntaxError* object).
                    1. Perform ContinueModuleLoading(_state_, _error_, _request_.[[ImportedNames]]).
                  1. Else if _module_.[[LoadedModules]] contains a LoadedModuleRequest Record _record_ such that ModuleRequestsEqual(_record_, _request_) is *true*, then
                    1. Perform InnerModuleLoading(_state_, _record_.[[Module]], _request_.[[ImportedNames]]).
                  1. Else,
                    1. Perform HostLoadImportedModule(_module_, _request_, _state_.[[HostDefined]], _state_).
                    1. NOTE: HostLoadImportedModule will call FinishLoadingImportedModule, which re-enters the graph loading process through ContinueModuleLoading.
                  1. If _state_.[[IsLoading]] is *false*, return ~unused~.
              1. Assert: _state_.[[PendingModulesCount]] ≥ 1.
              1. Set _state_.[[PendingModulesCount]] to _state_.[[PendingModulesCount]] - 1.
              1. If _state_.[[PendingModulesCount]] = 0, then
                1. Set _state_.[[IsLoading]] to *false*.
                1. For each Cyclic Module Record _loaded_ of _state_.[[Visited]], do
                  1. If _loaded_.[[Status]] is ~new~, set _loaded_.[[Status]] to ~unlinked~.
                1. Perform ! Call(_state_.[[PromiseCapability]].[[Resolve]], *undefined*, « *undefined* »).
              1. Return ~unused~.
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-ContinueModuleLoading" type="abstract operation">
            <h1>
              ContinueModuleLoading (
                _state_: a GraphLoadingState Record,
                _moduleCompletion_: either a normal completion containing a Module Record or a throw completion,
                <ins>_importedNames_: ~all~ or a List of Strings,</ins>
              ): ~unused~
            </h1>
            <dl class="header">
              <dt>description</dt>
              <dd>It is used to re-enter the loading process after a call to HostLoadImportedModule.</dd>
            </dl>

            <emu-alg>
              1. If _state_.[[IsLoading]] is *false*, return ~unused~.
              1. If _moduleCompletion_ is a normal completion, then
                1. Perform InnerModuleLoading(_state_, _moduleCompletion_.[[Value]], <ins>_importedNames_</ins>).
              1. Else,
                1. Set _state_.[[IsLoading]] to *false*.
                1. Perform ! Call(_state_.[[PromiseCapability]].[[Reject]], *undefined*, « _moduleCompletion_.[[Value]] »).
              1. Return ~unused~.
            </emu-alg>
          </emu-clause>
        </emu-clause>

        <emu-clause id="sec-moduledeclarationlinking" type="concrete method" oldids="sec-moduledeclarationinstantiation">
          <h1>Link ( ): either a normal completion containing ~unused~ or a throw completion</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>a Cyclic Module Record _module_</dd>

            <dt>description</dt>
            <dd>On success, Link transitions this module's [[Status]] from ~unlinked~ to ~linked~. On failure, an exception is thrown and this module's [[Status]] remains ~unlinked~. (Most of the work is done by the auxiliary function InnerModuleLinking.)</dd>
          </dl>

          <emu-note type="editor">
            <p>TODO: Either we add an _importedNames_ parameter, or dynamic import will have to be responsible for linking all the defrred reexports.</p>
            <p>If we add that parameter, we must be careful because the used deferred re-exports of a module should be linked _after_ calling InitializeEnvironment on the module itself.</p>
          </emu-note>

          <emu-alg>
            1. Assert: _module_.[[Status]] is one of ~unlinked~, ~linked~, ~evaluating-async~, or ~evaluated~.
            1. Let _stack_ be a new empty List.
            1. Let _result_ be Completion(InnerModuleLinking(_module_, _stack_, 0)).
            1. If _result_ is an abrupt completion, then
              1. For each Cyclic Module Record _m_ of _stack_, do
                1. Assert: _m_.[[Status]] is ~linking~.
                1. Set _m_.[[Status]] to ~unlinked~.
              1. Assert: _module_.[[Status]] is ~unlinked~.
              1. Return ? _result_.
            1. Assert: _module_.[[Status]] is one of ~linked~, ~evaluating-async~, or ~evaluated~.
            1. Assert: _stack_ is empty.
            1. Return ~unused~.
          </emu-alg>

          <emu-clause id="sec-InnerModuleLinking" type="abstract operation" oldids="sec-innermoduleinstantiation">
            <h1>
              InnerModuleLinking (
                _module_: a Module Record,
                _stack_: a List of Cyclic Module Records,
                _index_: a non-negative integer,
              ): either a normal completion containing a non-negative integer or a throw completion
            </h1>
            <dl class="header">
              <dt>description</dt>
              <dd>It is used by Link to perform the actual linking process for _module_, as well as recursively on all other modules in the dependency graph. The _stack_ and _index_ parameters, as well as a module's [[DFSAncestorIndex]] field, keep track of the depth-first search (DFS) traversal. In particular, [[DFSAncestorIndex]] is used to discover strongly connected components (SCCs), such that all modules in an SCC transition to ~linked~ together.</dd>
            </dl>

            <emu-alg>
              1. If _module_ is not a Cyclic Module Record, then
                1. Perform ? _module_.Link().
                1. Return _index_.
              1. If _module_.[[Status]] is one of ~linking~, ~linked~, ~evaluating-async~, or ~evaluated~, then
                1. Return _index_.
              1. Assert: _module_.[[Status]] is ~unlinked~.
              1. Set _module_.[[Status]] to ~linking~.
              1. Let _moduleIndex_ be _index_.
              1. Set _module_.[[DFSAncestorIndex]] to _index_.
              1. Set _index_ to _index_ + 1.
              1. Append _module_ to _stack_.
              1. <ins>Set _index_ to ? LinkRequestedModules(_module_, _module_, _module_.[[RequestedModules]], _stack_, _index_).</ins>
              1. <del>For each ModuleRequest Record _request_ of _module_.[[RequestedModules]], do</del>
                1. <del>Let _requiredModule_ be GetImportedModule(_module_, _request_).</del>
                1. <del>Set _index_ to ? InnerModuleLinking(_requiredModule_, _stack_, _index_).</del>
                1. <del>If _requiredModule_ is a Cyclic Module Record, then</del>
                  1. <del>Assert: _requiredModule_.[[Status]] is one of ~linking~, ~linked~, ~evaluating-async~, or ~evaluated~.</del>
                  1. <del>Assert: _requiredModule_.[[Status]] is ~linking~ if and only if _stack_ contains _requiredModule_.</del>
                  1. <del>If _requiredModule_.[[Status]] is ~linking~, then</del>
                    1. <del>Set _module_.[[DFSAncestorIndex]] to min(_module_.[[DFSAncestorIndex]], _requiredModule_.[[DFSAncestorIndex]]).</del>
              1. Perform ? _module_.InitializeEnvironment().
              1. Assert: _module_ occurs exactly once in _stack_.
              1. Assert: _module_.[[DFSAncestorIndex]] ≤ _moduleIndex_.
              1. If _module_.[[DFSAncestorIndex]] = _moduleIndex_, then
                1. Let _done_ be *false*.
                1. Repeat, while _done_ is *false*,
                  1. Let _requiredModule_ be the last element of _stack_.
                  1. Remove the last element of _stack_.
                  1. Assert: _requiredModule_ is a Cyclic Module Record.
                  1. Set _requiredModule_.[[Status]] to ~linked~.
                  1. If _requiredModule_ and _module_ are the same Module Record, set _done_ to *true*.
              1. Return _index_.
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-LinkRequestedModules" type="abstract operation">
            <h1>
              <ins>
                LinkRequestedModules (
                  _referrer_: a Cyclic Module Record,
                  _dfsAncestor_: a Cyclic Module Record,
                  _moduleRequests_: a List of ModuleRequest Records,
                  _stack_: a List of Cyclic Module Records,
                  _index_: a non-negative integer,
                ): either a normal completion containing a non-negative integer or a throw completion
              </ins>
            </h1>
            <dl class="header"></dl>
            <emu-alg>
              1. For each ModuleRequest Record _request_ of _moduleRequests_, do
                1. Let _requiredModule_ be GetImportedModule(_referrer_, _request_).
                1. Set _index_ to ? InnerModuleLinking(_requiredModule_, _stack_, _index_).
                1. If _requiredModule_ is a Cyclic Module Record, then
                  1. Assert: _requiredModule_.[[Status]] is one of ~linking~, ~linked~, ~evaluating-async~, or ~evaluated~.
                  1. Assert: _requiredModule_.[[Status]] is ~linking~ if and only if _stack_ contains _requiredModule_.
                  1. If _requiredModule_.[[Status]] is ~linking~, then
                    1. Set _dfsAncestor_.[[DFSAncestorIndex]] to min(_dfsAncestor_.[[DFSAncestorIndex]], _requiredModule_.[[DFSAncestorIndex]]).
                  1. Let _indirectRequests_ be GetOptionalIndirectExportsModuleRequests(_requiredModule_, _request_.[[ImportedNames]]).
                  1. Set _index_ to ? LinkRequestedModules(_requiredModule_, _dfsAncestor_, _indirectRequests_, _stack_, _index_).
              1. Return _index_.
            </emu-alg>

            <emu-note type="editor">
              TODO: There is an infinite loop if two modules `export defer` from each other.
            </emu-note>
          </emu-clause>
        </emu-clause>

        <emu-clause id="sec-moduleevaluation" type="concrete method">
          <h1>Evaluate ( ): a Promise</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>a Cyclic Module Record _module_</dd>

            <dt>description</dt>
            <dd>Evaluate transitions this module's [[Status]] from ~linked~ to either ~evaluating-async~ or ~evaluated~. The first time it is called on a module in a given strongly connected component, Evaluate creates and returns a Promise which resolves when the module has finished evaluating. This Promise is stored in the [[TopLevelCapability]] field of the [[CycleRoot]] for the component. Future invocations of Evaluate on any module in the component return the same Promise. (Most of the work is done by the auxiliary function InnerModuleEvaluation.)</dd>
          </dl>

          <emu-note type="editor">TODO: This needs to be updated</emu-note>

          <emu-alg>
            1. Assert: None of _module_ or any of its recursive dependencies have [[Status]] set to ~evaluating~, ~linking~, ~unlinked~, or ~new~.
            1. Assert: _module_.[[Status]] is one of ~linked~, ~evaluating-async~, or ~evaluated~.
            1. If _module_.[[Status]] is either ~evaluating-async~ or ~evaluated~, set _module_ to _module_.[[CycleRoot]].
            1. If _module_.[[TopLevelCapability]] is not ~empty~, then
              1. Return _module_.[[TopLevelCapability]].[[Promise]].
            1. Let _stack_ be a new empty List.
            1. Let _capability_ be ! NewPromiseCapability(%Promise%).
            1. Set _module_.[[TopLevelCapability]] to _capability_.
            1. Let _result_ be Completion(InnerModuleEvaluation(_module_, _stack_, 0)).
            1. If _result_ is an abrupt completion, then
              1. For each Cyclic Module Record _m_ of _stack_, do
                1. Assert: _m_.[[Status]] is ~evaluating~.
                1. Set _m_.[[Status]] to ~evaluated~.
                1. Set _m_.[[EvaluationError]] to _result_.
              1. Assert: _module_.[[Status]] is ~evaluated~.
              1. Assert: _module_.[[EvaluationError]] is _result_.
              1. Perform ! Call(_capability_.[[Reject]], *undefined*, « _result_.[[Value]] »).
            1. Else,
              1. Assert: _module_.[[Status]] is either ~evaluating-async~ or ~evaluated~.
              1. Assert: _module_.[[EvaluationError]] is ~empty~.
              1. If _module_.[[Status]] is ~evaluated~, then
                1. NOTE: This implies that evaluation of _module_ completed synchronously.
                1. Assert: _module_.[[AsyncEvaluationOrder]] is ~unset~.
                1. Perform ! Call(_capability_.[[Resolve]], *undefined*, « *undefined* »).
              1. Assert: _stack_ is empty.
            1. Return _capability_.[[Promise]].
          </emu-alg>

          <emu-clause id="sec-innermoduleevaluation" type="abstract operation">
            <h1>
              InnerModuleEvaluation (
                _module_: a Module Record,
                _stack_: a List of Cyclic Module Records,
                _index_: a non-negative integer,
              ): either a normal completion containing a non-negative integer or a throw completion
            </h1>
            <dl class="header">
              <dt>description</dt>
              <dd>It is used by Evaluate to perform the actual evaluation process for _module_, as well as recursively on all other modules in the dependency graph. The _stack_ and _index_ parameters, as well as _module_'s [[DFSAncestorIndex]] field, are used the same way as in InnerModuleLinking.</dd>
            </dl>

            <emu-alg>
              1. If _module_ is not a Cyclic Module Record, then
                1. Perform ? EvaluateModuleSync(_module_).
                1. Return _index_.
              1. If _module_.[[Status]] is either ~evaluating-async~ or ~evaluated~, then
                1. If _module_.[[EvaluationError]] is ~empty~, return _index_.
                1. Otherwise, return ? _module_.[[EvaluationError]].
              1. If _module_.[[Status]] is ~evaluating~, return _index_.
              1. Assert: _module_.[[Status]] is ~linked~.
              1. Set _module_.[[Status]] to ~evaluating~.
              1. Let _moduleIndex_ be _index_.
              1. Set _module_.[[DFSAncestorIndex]] to _index_.
              1. Set _module_.[[PendingAsyncDependencies]] to 0.
              1. Set _index_ to _index_ + 1.
              1. <del>Let _evaluationList_ be a new empty List.</del>
              1. <del>For each ModuleRequest Record _required_ of _module_.[[RequestedModules]], do</del>
                1. <del>Let _requiredModule_ be GetImportedModule(_module_, _required_.[[Specifier]]).</del>
                1. <del>If _required_.[[Phase]] is ~defer~, then</del>
                  1. <del>Let _additionalModules_ be GatherAsynchronousTransitiveDependencies(_requiredModule_).</del>
                  1. <del>For each Module Record _additionalModule_ of _additionalModules_, do</del>
                    1. <del>If _evaluationList_ does not contain _additionalModule_, then</del>
                      1. <del>Append _additionalModule_ to _evaluationList_.</del>
                1. <del>Else if _evaluationList_ does not contain _requiredModule_, then</del>
                  1. <del>Append _requiredModule_ to _evaluationList_.</del>
              1. Append _module_ to _stack_.
              1. <ins>Set _index_ to ? EvaluateRequestedModules(_module_, _module_, _module_.[[RequestedModules]], _stack_, _index_).</ins>
              1. <del>For each Module Record _requiredModule_ of _evaluationList_, do</del>
                1. <del>Set _index_ to ? InnerModuleEvaluation(_requiredModule_, _stack_, _index_).</del>
                1. <del>If _requiredModule_ is a Cyclic Module Record, then</del>
                  1. <del>Assert: _requiredModule_.[[Status]] is one of ~evaluating~, ~evaluating-async~, or ~evaluated~.</del>
                  1. <del>Assert: _requiredModule_.[[Status]] is ~evaluating~ if and only if _stack_ contains _requiredModule_.</del>
                  1. <del>If _requiredModule_.[[Status]] is ~evaluating~, then</del>
                    1. <del>Set _module_.[[DFSAncestorIndex]] to min(_module_.[[DFSAncestorIndex]], _requiredModule_.[[DFSAncestorIndex]]).</del>
                  1. <del>Else,</del>
                    1. <del>Set _requiredModule_ to _requiredModule_.[[CycleRoot]].</del>
                    1. <del>Assert: _requiredModule_.[[Status]] is either ~evaluating-async~ or ~evaluated~.</del>
                    1. <del>If _requiredModule_.[[EvaluationError]] is not ~empty~, return ? _requiredModule_.[[EvaluationError]].</del>
                  1. <del>If _requiredModule_.[[AsyncEvaluationOrder]] is an integer, then</del>
                    1. <del>Set _module_.[[PendingAsyncDependencies]] to _module_.[[PendingAsyncDependencies]] + 1.</del>
                    1. <del>Append _module_ to _requiredModule_.[[AsyncParentModules]].</del>
              1. If _module_.[[PendingAsyncDependencies]] > 0 or _module_.[[HasTLA]] is *true*, then
                1. Assert: _module_.[[AsyncEvaluationOrder]] is ~unset~.
                1. Set _module_.[[AsyncEvaluationOrder]] to IncrementModuleAsyncEvaluationCount().
                1. If _module_.[[PendingAsyncDependencies]] = 0, perform ExecuteAsyncModule(_module_).
              1. Else,
                1. Perform ? <emu-meta effects="user-code">_module_.ExecuteModule()</emu-meta>.
              1. Assert: _module_ occurs exactly once in _stack_.
              1. Assert: _module_.[[DFSAncestorIndex]] ≤ _moduleIndex_.
              1. If _module_.[[DFSAncestorIndex]] = _moduleIndex_, then
                1. Let _done_ be *false*.
                1. Repeat, while _done_ is *false*,
                  1. Let _requiredModule_ be the last element of _stack_.
                  1. Remove the last element of _stack_.
                  1. Assert: _requiredModule_ is a Cyclic Module Record.
                  1. Assert: _requiredModule_.[[AsyncEvaluationOrder]] is either an integer or ~unset~.
                  1. If _requiredModule_.[[AsyncEvaluationOrder]] is ~unset~, set _requiredModule_.[[Status]] to ~evaluated~.
                  1. Otherwise, set _requiredModule_.[[Status]] to ~evaluating-async~.
                  1. If _requiredModule_ and _module_ are the same Module Record, set _done_ to *true*.
                  1. Set _requiredModule_.[[CycleRoot]] to _module_.
              1. Return _index_.
            </emu-alg>
            <emu-note>
              <p>A module is ~evaluating~ while it is being traversed by InnerModuleEvaluation. A module is ~evaluated~ on execution completion or ~evaluating-async~ during execution if its [[HasTLA]] field is *true* or if it has asynchronous dependencies.</p>
            </emu-note>
            <emu-note>
              <p>Any modules depending on a module of an asynchronous cycle when that cycle is not ~evaluating~ will instead depend on the execution of the root of the cycle via [[CycleRoot]]. This ensures that the cycle state can be treated as a single strongly connected component through its root module state.</p>
            </emu-note>
          </emu-clause>

          <emu-clause id="sec-EvaluateRequestedModules" type="abstract operation">
            <h1>
              <ins>
                EvaluateRequestedModules (
                  _referrer_: a Cyclic Module Record,
                  _dfsAncestor_: a Cyclic Module Record,
                  _moduleRequests_: a List of ModuleRequest Records,
                  _stack_: a List of Cyclic Module Records,
                  _index_: a non-negative integer,
                ): either a normal completion containing a non-negative integer or a throw completion
              </ins>
            </h1>
            <dl class="header"></dl>

            <emu-alg>
              1. Let _evaluationList_ be a new empty List.
              1. For each ModuleRequest Record _request_ of _moduleRequests_, do
                1. Let _requiredModule_ be GetImportedModule(_referrer_, _request_.[[Specifier]]).
                1. If _request_.[[Phase]] is ~defer~, then
                  1. Let _additionalModules_ be GatherAsynchronousTransitiveDependencies(_requiredModule_).
                  1. For each Module Record _additionalModule_ of _additionalModules_, do
                    1. If _evaluationList_ does not contain _additionalModule_, then
                      1. Append _additionalModule_ to _evaluationList_.
                1. Else if _evaluationList_ does not contain _requiredModule_, then
                  1. Append _requiredModule_ to _evaluationList_.
              1. For each Module Record _requiredModule_ of _evaluationList_, do
                1. Set _index_ to ? InnerModuleEvaluation(_requiredModule_, _stack_, _index_).
                1. If _requiredModule_ is a Cyclic Module Record, then
                  1. Assert: _requiredModule_.[[Status]] is one of ~evaluating~, ~evaluating-async~, or ~evaluated~.
                  1. Assert: _requiredModule_.[[Status]] is ~evaluating~ if and only if _stack_ contains _requiredModule_.
                  1. If _requiredModule_.[[Status]] is ~evaluating~, then
                    1. Set _dfsAncestor_.[[DFSAncestorIndex]] to min(_dfsAncestor_.[[DFSAncestorIndex]], _requiredModule_.[[DFSAncestorIndex]]).
                  1. Else,
                    1. Set _requiredModule_ to _requiredModule_.[[CycleRoot]].
                    1. Assert: _requiredModule_.[[Status]] is either ~evaluating-async~ or ~evaluated~.
                    1. If _requiredModule_.[[EvaluationError]] is not ~empty~, return ? _requiredModule_.[[EvaluationError]].
                  1. If _requiredModule_.[[AsyncEvaluationOrder]] is an integer, then
                    1. Set _dfsAncestor_.[[PendingAsyncDependencies]] to _dfsAncestor_.[[PendingAsyncDependencies]] + 1.
                    1. Append _dfsAncestor_ to _requiredModule_.[[AsyncParentModules]].
                  1. Let _indirectRequests_ be GetOptionalIndirectExportsModuleRequests(_requiredModule_, <span style="background:yellow">(TODO: request)</span>.[[ImportedNames]]).
                  1. Set _index_ to ? EvaluateRequestedModules(_requiredModule_, _dfsAncestor_, _indirectRequests_, _stack_, _index_).
              1. Return _index_.
            </emu-alg>

            <emu-note type="editor">
              TODO: There is an infinite loop if two modules `export defer` from each other.
            </emu-note>
          </emu-clause>

          <emu-clause id="sec-GatherAsynchronousTransitiveDependencies" type="abstract operation">
            <h1>
              GatherAsynchronousTransitiveDependencies (
                _module_: a Module Record,
                optional _seen_: a List of Module Records
              ): a List of Module Records
            </h1>
            <dl class="header">
              <dt>description</dt>
              <dd>Collects the direct post-order list of asynchronous unexecuted transitive dependencies, stopping the depth-first search for a branch when an asynchronous dependency is found.</dd>
            </dl>

            <emu-note type="editor">TODO: This needs to be aware of the `export defer` semantics, to know where to recourse</emu-note>

            <emu-alg>
              1. If _seen_ is not present, set _seen_ to a new empty List.
              1. Let _result_ be a new empty List.
              1. If _seen_ contains _module_, return _result_.
              1. Append _module_ to _seen_.
              1. If _module_ is not a Cyclic Module Record, return _result_.
              1. If _module_.[[Status]] is either ~evaluating~ or ~evaluated~, return _result_.
              1. If _module_.[[HasTLA]] is *true*, then
                1. Append _module_ to _result_.
                1. Return _result_.
              1. For each ModuleRequest Record _required_ of _module_.[[RequestedModules]], do
                1. Let _requiredModule_ be GetImportedModule(_module_, _required_.[[Specifier]]).
                1. Let _additionalModules_ be GatherAsynchronousTransitiveDependencies(_requiredModule_, _seen_).
                1. For each Module Record _m_ of _additionalModules_, do
                  1. If _result_ does not contain _m_, append _m_ to _result_.
              1. Return _result_.
            </emu-alg>
          </emu-clause>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-source-text-module-records" number="7">
        <h1>Source Text Module Records</h1>

        <emu-clause id="sec-parsemodule" type="abstract operation">
          <h1>
            ParseModule (
              _sourceText_: ECMAScript source text,
              _realm_: a Realm Record,
              _hostDefined_: anything,
            ): a Source Text Module Record or a non-empty List of *SyntaxError* objects
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It creates a Source Text Module Record based upon the result of parsing _sourceText_ as a |Module|.</dd>
          </dl>
          <emu-alg>
            1. Let _body_ be ParseText(_sourceText_, |Module|).
            1. If _body_ is a List of errors, return _body_.
            1. Let _requestedModules_ be the ModuleRequests of _body_.
            1. Let _importEntries_ be the ImportEntries of _body_.
            1. Let _importedBoundNames_ be ImportedLocalNames(_importEntries_).
            1. Let _indirectExportEntries_ be a new empty List.
            1. Let _localExportEntries_ be a new empty List.
            1. Let _starExportEntries_ be a new empty List.
            1. Let _exportEntries_ be the ExportEntries of _body_.
            1. For each ExportEntry Record _ee_ of _exportEntries_, do
              1. If _ee_.[[ModuleRequest]] is *null*, then
                1. If _importedBoundNames_ does not contain _ee_.[[LocalName]], then
                  1. Append _ee_ to _localExportEntries_.
                1. Else,
                  1. Let _ie_ be the element of _importEntries_ whose [[LocalName]] is _ee_.[[LocalName]].
                  1. If _ie_.[[ImportName]] is ~namespace-object~, then
                    1. NOTE: This is a re-export of an imported module namespace object.
                    1. Append _ee_ to _localExportEntries_.
                  1. Else,
                    1. NOTE: This is a re-export of a single name.
                    1. Append the ExportEntry Record { [[ModuleRequest]]: _ie_.[[ModuleRequest]], [[ImportName]]: _ie_.[[ImportName]], [[LocalName]]: *null*, [[ExportName]]: _ee_.[[ExportName]] } to _indirectExportEntries_.
              1. Else if _ee_.[[ImportName]] is ~all-but-default~, then
                1. Assert: _ee_.[[ExportName]] is *null*.
                1. Append _ee_ to _starExportEntries_.
              1. Else,
                1. Append _ee_ to _indirectExportEntries_.
            1. <ins>Let _optionalIndirectExportsEntries_ be OptionalIndirectExportEntries of _body_.</ins>
            1. Let _async_ be _body_ Contains `await`.
            1. Return Source Text Module Record { [[Realm]]: _realm_, [[Environment]]: ~empty~, [[Namespace]]: ~empty~, [[CycleRoot]]: ~empty~, [[HasTLA]]: _async_, [[AsyncEvaluationOrder]]: ~unset~, [[TopLevelCapability]]: ~empty~, [[AsyncParentModules]]: « », [[PendingAsyncDependencies]]: ~empty~, [[Status]]: ~new~, [[EvaluationError]]: ~empty~, [[HostDefined]]: _hostDefined_, [[ECMAScriptCode]]: _body_, [[Context]]: ~empty~, [[ImportMeta]]: ~empty~, [[RequestedModules]]: _requestedModules_, [[LoadedModules]]: « », [[ImportEntries]]: _importEntries_, [[LocalExportEntries]]: _localExportEntries_, [[IndirectExportEntries]]: _indirectExportEntries_, [[StarExportEntries]]: _starExportEntries_, <ins>[[OptionalIndirectExportEntries]]: _optionalIndirectExportsEntries_,</ins> [[DFSAncestorIndex]]: ~empty~ }.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-GetOptionalIndirectExportsModuleRequests" type="abstract operation" number="100">
        <h1>
          <ins>
            GetOptionalIndirectExportsModuleRequests (
              _module_: a Cyclic Module Record,
              _importedNames_: ~all~ or a List of Strings,
            ): a List of ModuleRequest Records
          </ins>
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd></dd>
        </dl>

        <emu-alg>
          1. Let _requests_ be a new empty List.
          1. For each ExportEntry Record _oie_ of _module_.[[OptionalIndirectExportEntries]], do
            1. If _importedNames_ is ~all~ or _importedNames_ contains _oie_.[[ExportName]], then
              1. Let _nextRequest_ be _oie_.[[ModuleRequest]].
              1. Let _existingRequest_ be ~empty~.
              1. For each ModuleRequest Record _r_ in _requests_, do
                1. If _existingRequest_ is ~empty~ and ModuleRequestsEqual(_r_, _nextRequest_) is *true* and _r_.[[Phase]] is _nextRequest_.[[Phase]], then
                  1. Set _existingRequest_ to _r_.
              1. Let _newImportedNames_ be ~all~.
              1. Assert: _oie_.[[ImportName]] is a String or ~all~.
              1. If _oie_.[[ImportName]] is a String, set _newImportedNames_ to « _oie_.[[ImportName]] ».
              1. If _existingRequest_ is ~empty~, then
                1. Let _request_ be the ModuleRequest Record { [[Specifier]]: _nextRequest_.[[Specifier]], [[Attributes]]: _nextRequest_.[[Attributes]], [[Phase]]: _nextRequest_.[[Phase]], [[ImportedNames]]: _newImportedNames_ }.
                1. Append _request_ to _requests_.
              1. Else,
                1. Set _existingRequest_.[[ImportedNames]] to MergeImportedNames(_existingRequest_.[[ImportedNames]], _newImportedNames_).
          1. Return _requests_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-mergeimportednames" type="abstract operation">
        <h1>
          <ins>
            MergeImportedNames (
              _a_: ~all~ or a List of Strings,
              _b_: ~all~ or a List of Strings,
            ): ~all~ or a List of Strings
          </ins>
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd></dd>
        </dl>

        <emu-alg>
          1. If _a_ is ~all~ or _b_ is ~all~, return ~all~.
          1. Return the list-concatenation of _a_ and _b_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-exports" number="3">
      <h1>Exports</h1>

      <h2>Syntax</h2>
      <emu-grammar type="definition">
        ExportDeclaration :
          `export` <ins>`defer`?</ins> ExportFromClause FromClause WithClause? `;`
          `export` NamedExports `;`
          `export` VariableStatement[~Yield, +Await]
          `export` Declaration[~Yield, +Await]
          `export` `default` HoistableDeclaration[~Yield, +Await, +Default]
          `export` `default` ClassDeclaration[~Yield, +Await, +Default]
          `export` `default` [lookahead &notin; { `function`, `async` [no LineTerminator here] `function`, `class` }] AssignmentExpression[+In, ~Yield, +Await] `;`

        ExportFromClause :
          `*`
          <del>`*` `as` ModuleExportName</del>
          <ins>NamedNamespaceExport</ins>
          NamedExports

        <ins>
        NamedNamespaceExport :
          `*` `as` ModuleExportName
        </ins>

        NamedExports :
          `{` `}`
          `{` ExportsList `}`
          `{` ExportsList `,` `}`

        ExportsList :
          ExportSpecifier
          ExportsList `,` ExportSpecifier

        ExportSpecifier :
          ModuleExportName
          ModuleExportName `as` ModuleExportName
      </emu-grammar>

      <emu-clause id="sec-exports-static-semantics-early-errors">
        <h1>Static Semantics: Early Errors</h1>
        <emu-grammar>ExportDeclaration : `export` NamedExports `;`</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if ReferencedBindings of |NamedExports| contains any |StringLiteral|s.
          </li>
          <li>
            For each |IdentifierName| _n_ in ReferencedBindings of |NamedExports|: It is a Syntax Error if StringValue of _n_ is a |ReservedWord| or the StringValue of _n_ is one of *"implements"*, *"interface"*, *"let"*, *"package"*, *"private"*, *"protected"*, *"public"*, or *"static"*.
          </li>
        </ul>
        <emu-note>
          <p>The above rule means that each ReferencedBindings of |NamedExports| is treated as an |IdentifierReference|.</p>
        </emu-note>
        <emu-grammar><ins>ExportDeclaration : `export` `defer` ExportFromClause FromClause WithClause? `;`</ins></emu-grammar>
        <ul>
          <li>
            <ins>It is a Syntax Error if |ExportFromClause| is `*`.</ins>
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-static-semantics-exportednames" type="sdo" number="3">
        <h1>Static Semantics: ExportedNames ( ): a List of Strings</h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>ExportedNames are the externally visible names that a |Module| explicitly maps to one of its local name bindings.</p>
        </emu-note>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. Let _names1_ be ExportedNames of |ModuleItemList|.
          1. Let _names2_ be ExportedNames of |ModuleItem|.
          1. Return the list-concatenation of _names1_ and _names2_.
        </emu-alg>
        <emu-grammar>ModuleItem : ExportDeclaration</emu-grammar>
        <emu-alg>
          1. Return the ExportedNames of |ExportDeclaration|.
        </emu-alg>
        <emu-grammar>
          ModuleItem :
            ImportDeclaration
            StatementListItem
        </emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` <ins>`defer`?</ins> ExportFromClause FromClause WithClause? `;`</emu-grammar>
        <emu-alg>
          1. Return the ExportedNames of |ExportFromClause|.
        </emu-alg>
        <emu-grammar>ExportFromClause : `*`</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ExportFromClause : `*` `as` ModuleExportName</emu-grammar>
        <emu-alg>
          1. Return a List whose sole element is the StringValue of |ModuleExportName|.
        </emu-alg>
        <emu-grammar>ExportFromClause : NamedExports</emu-grammar>
        <emu-alg>
          1. Return the ExportedNames of |NamedExports|.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` VariableStatement</emu-grammar>
        <emu-alg>
          1. Return the BoundNames of |VariableStatement|.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` Declaration</emu-grammar>
        <emu-alg>
          1. Return the BoundNames of |Declaration|.
        </emu-alg>
        <emu-grammar>
          ExportDeclaration :
            `export` `default` HoistableDeclaration
            `export` `default` ClassDeclaration
            `export` `default` AssignmentExpression `;`
        </emu-grammar>
        <emu-alg>
          1. Return « *"default"* ».
        </emu-alg>
        <emu-grammar>NamedExports : `{` `}`</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ExportsList : ExportsList `,` ExportSpecifier</emu-grammar>
        <emu-alg>
          1. Let _names1_ be the ExportedNames of |ExportsList|.
          1. Let _names2_ be the ExportedNames of |ExportSpecifier|.
          1. Return the list-concatenation of _names1_ and _names2_.
        </emu-alg>
        <emu-grammar>ExportSpecifier : ModuleExportName</emu-grammar>
        <emu-alg>
          1. Return a List whose sole element is the StringValue of |ModuleExportName|.
        </emu-alg>
        <emu-grammar>ExportSpecifier : ModuleExportName `as` ModuleExportName</emu-grammar>
        <emu-alg>
          1. Return a List whose sole element is the StringValue of the second |ModuleExportName|.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-exportentries" type="sdo" number="4">
        <h1>Static Semantics: ExportEntries ( ): a List of ExportEntry Records</h1>
        <dl class="header">
        </dl>
        <emu-grammar>Module : [empty]</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. Let _entries1_ be ExportEntries of |ModuleItemList|.
          1. Let _entries2_ be ExportEntries of |ModuleItem|.
          1. Return the list-concatenation of _entries1_ and _entries2_.
        </emu-alg>
        <emu-grammar>
          ModuleItem :
            ImportDeclaration
            StatementListItem
        </emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` <ins>`defer`?</ins> ExportFromClause FromClause WithClause? `;`</emu-grammar>
        <emu-alg>
          1. Let _module_ be the sole element of ModuleRequests of |FromClause|.
          1. Return ExportEntriesForModule of |ExportFromClause| with argument _module_.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` NamedExports `;`</emu-grammar>
        <emu-alg>
          1. Return ExportEntriesForModule of |NamedExports| with argument *null*.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` VariableStatement</emu-grammar>
        <emu-alg>
          1. Let _entries_ be a new empty List.
          1. Let _names_ be the BoundNames of |VariableStatement|.
          1. For each element _name_ of _names_, do
            1. Append the ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _name_, [[ExportName]]: _name_ } to _entries_.
          1. Return _entries_.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` Declaration</emu-grammar>
        <emu-alg>
          1. Let _entries_ be a new empty List.
          1. Let _names_ be the BoundNames of |Declaration|.
          1. For each element _name_ of _names_, do
            1. Append the ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _name_, [[ExportName]]: _name_ } to _entries_.
          1. Return _entries_.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` `default` HoistableDeclaration</emu-grammar>
        <emu-alg>
          1. Let _names_ be BoundNames of |HoistableDeclaration|.
          1. Let _localName_ be the sole element of _names_.
          1. Return a List whose sole element is a new ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _localName_, [[ExportName]]: *"default"* }.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` `default` ClassDeclaration</emu-grammar>
        <emu-alg>
          1. Let _names_ be BoundNames of |ClassDeclaration|.
          1. Let _localName_ be the sole element of _names_.
          1. Return a List whose sole element is a new ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _localName_, [[ExportName]]: *"default"* }.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` `default` AssignmentExpression `;`</emu-grammar>
        <emu-alg>
          1. Let _entry_ be the ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: *"\*default\*"*, [[ExportName]]: *"default"* }.
          1. Return « _entry_ ».
        </emu-alg>
        <emu-note>
          <p>*"\*default\*"* is used within this specification as a synthetic name for anonymous default export values. See <emu-xref href="#note-star-default-star">this note</emu-xref> for more details.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-static-semantics-optionalindirectexportentries" type="sdo">
        <h1>
          <ins>
            Static Semantics: OptionalIndirectExportEntries ( ): a List of ExportEntry Records
          </ins>
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>Module : [empty]</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. Let _entries1_ be OptionalIndirectExportEntries of |ModuleItemList|.
          1. Let _entries2_ be OptionalIndirectExportEntries of |ModuleItem|.
          1. Return the list-concatenation of _entries1_ and _entries2_.
        </emu-alg>
        <emu-grammar>
          ModuleItem :
            ImportDeclaration
            StatementListItem

          ExportDeclaration :
            `export` ExportFromClause FromClause WithClause? `;`
            `export` NamedExports `;`
            `export` VariableStatement
            `export` Declaration
            `export` `default` HoistableDeclaration
            `export` `default` ClassDeclaration
            `export` `default` AssignmentExpression `;`
        </emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` `defer` ExportFromClause FromClause WithClause? `;`</emu-grammar>
        <emu-alg>
          1. Return ExportEntries of |ExportDeclaration|.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>
